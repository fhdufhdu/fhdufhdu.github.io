<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on fhdufhdu</title>
        <link>https://fhdufhdu.github.io/post/</link>
        <description>Recent content in Posts on fhdufhdu</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko-KR</language>
<<<<<<< HEAD
        <lastBuildDate>Thu, 11 Jan 2024 08:54:00 +0900</lastBuildDate><atom:link href="https://fhdufhdu.github.io/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[PostgreSQL] 쿼리 결과를 임시로 저장해서 사용하는 방법(with절)</title>
        <link>https://fhdufhdu.github.io/post/9/</link>
        <pubDate>Thu, 11 Jan 2024 08:54:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/9/</guid>
        <description>&lt;h1 id=&#34;with-절이란&#34;&gt;With 절이란?&lt;/h1&gt;
&lt;p&gt;복잡한 쿼리를 작성하다보면, 비슷한 쿼리를 여러번 사용해야할 때가 있다. 매번 똑같은 쿼리를 사용하면 실행 시간이 계속 늘어날 것 같고, 한번만 실행하고 싶을 때가 있을 것이다.&lt;/p&gt;
&lt;p&gt;이럴 때 필요한 것이 &lt;code&gt;with&lt;/code&gt;절이다. with절은 select 쿼리를 실행하고 해당 결과를 임시로 저장해준다. 이러한 것들은 &lt;code&gt;CTE(common table expression)&lt;/code&gt;라고 한다.&lt;/p&gt;
&lt;h1 id=&#34;사용법&#34;&gt;사용법&lt;/h1&gt;
&lt;h2 id=&#34;테이블-구조&#34;&gt;테이블 구조&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id      integer     &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;primary&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name    varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;)  &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    locale  varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;)  &lt;span style=&#34;color:#66d9ef&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;select-쿼리&#34;&gt;select 쿼리&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; temp_user &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; name &lt;span style=&#34;color:#66d9ef&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fhdu%&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; temp_user u1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;join&lt;/span&gt; temp_user u2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; u1.locale &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; u2.locale
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;temp_user에 결과를 저장해놓고 계속 불러와서 쓸 수 있게 도와준다.&lt;/p&gt;
&lt;h3 id=&#34;with절-여러개-사용&#34;&gt;with절 여러개 사용&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; temp_user &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; name &lt;span style=&#34;color:#66d9ef&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fhdu%&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;), temp_user2 &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; name &lt;span style=&#34;color:#66d9ef&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;woo%&amp;#34;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; temp_user u1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;join&lt;/span&gt; temp_user2 u2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; u1.locale &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; u2.locale
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위와 같이 &lt;code&gt;,&lt;/code&gt;기호로 하나의 쿼리에서 여러개의 with절을 사용할 수 있다.&lt;/p&gt;
</description>
        </item>
        <item>
=======
        <lastBuildDate>Wed, 10 Jan 2024 14:34:00 +0900</lastBuildDate><atom:link href="https://fhdufhdu.github.io/post/index.xml" rel="self" type="application/rss+xml" /><item>
>>>>>>> refs/remotes/origin/main
        <title>[PostgreSQL] [실무] 데이터를 일관되게 전달해 보자</title>
        <link>https://fhdufhdu.github.io/post/8/</link>
        <pubDate>Wed, 10 Jan 2024 14:34:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/8/</guid>
        <description>&lt;h1 id=&#34;문제&#34;&gt; 문제&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://fhdufhdu.github.io/post/7&#34; &gt;1편의 문제&lt;/a&gt;를 해결한 이후 새로운 이슈가 발생했다. 해당 이슈는 &lt;code&gt;게시글 리스트의 댓글 개수와 실제 게시글에 들어갔을 때 댓글 개수가 달라요&lt;/code&gt; 이다. 이전에 수정한 코드가 문제가 있던 것은 아니고, 기존의 로직 자체의 문제였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fhdufhdu.github.io/post/8/image.png&#34;
	width=&#34;678&#34;
	height=&#34;272&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;게시글 리스트(기글하드웨어) - 해당 이미지는 예시입니다.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;249&#34;
		data-flex-basis=&#34;598px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;위 이미지의 &lt;code&gt;델 oem 4090의 모험(완)&lt;/code&gt; 게시글을 보면 댓글이 6개라고 나와 있다. 그런데, 실제로 해당 게시글을 클릭해서 들어가면 5개, 4개 같이 댓글 개수가 줄어드는 버그가 있었다.&lt;/p&gt;
&lt;p&gt;이는 서비스의 댓글 정책에서 기인하는 문제이다. 해당 정책은 댓글의 노출이 &lt;code&gt;삭제, 차단, 신고, 위치, 순서&lt;/code&gt; 등의 조건에 영향을 받는 정책이다. 단순히 봐도 복잡할 것이 예상되지 않는가?&lt;/p&gt;
&lt;p&gt;그래서 그랬을까? 애초에 로직이 조금 이상했었다. 게시글 리스트를 가져올 때는 단순하게 삭제된 댓글을 제외한 개수를 가져와서 반환하고, 게시글 상세 정보 조회 시에는 실제로 댓글 리스트에 정책을 js 코드로 필터를 작성해서 반환했다. 그래서 댓글의 작성과 삭제가 빈번하게 일어나는 게시글일수록 점점 차이가 심하게 나기 시작했다.&lt;/p&gt;
&lt;p&gt;솔직히 처음 코드를 보고 조금 벙쪘다. 아무리 그래도 그렇지&amp;hellip; 두개의 댓글 개수 카운팅 방식이 같지 않다니&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;문제를-어떻게-해결할-것인가&#34;&gt;문제를 어떻게 해결할 것인가&lt;/h1&gt;
&lt;p&gt;문제의 원인을 파악하고 나서, 어떻게 해결할 지 고민이 많이 되었다. 곰곰히 생각하면서 세가지의 생각이 떠올랐다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;프론트엔드에게 처리 맞기기&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;절대 안된다.&lt;/li&gt;
&lt;li&gt;프론트엔드에게 처리를 맞기면 똑같은 문제가 발생할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;게시글 목록 조회시 댓글도 싹다 불러와서 정책 필터 적용시키기&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;전체 게시글 개수(n) * 전체 댓글 개수(m) = &lt;strong&gt;O(n*m)&lt;/strong&gt; 만큼의 시간 소모&lt;/li&gt;
&lt;li&gt;뭔가 딱봐도 시간이 오래 걸릴 것 같은 느낌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;orm을 제거하고 정책을 sql 쿼리에 녹여서 만들기&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;생각만해도 어렵고, 귀찮다.&lt;/li&gt;
&lt;li&gt;근데 이 방법 밖에 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;결론은 sql 쿼리를 사용하는 것이었다. 하지만 여기에도 문제가 존재한다.&lt;/p&gt;
&lt;h3 id=&#34;추가-문제&#34;&gt;추가 문제&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;기존 response dto를 유지해야함.&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;이것이 제일 큰 문제이다.&lt;/li&gt;
&lt;li&gt;orm은 join시 자동으로 아래 예시 처럼 nest object를 만들어준다.&lt;/li&gt;
&lt;li&gt;기존 response dto는 orm의 nest object에 강하게 의존하고 있다.&lt;/li&gt;
&lt;li&gt;sql로도 해당 nest object를 만들 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일반적으로 sql로 내려받은 데이터는 object안에 object가 없는 평면적인 데이터이다. 이를 코드상으로 해결하기에는 꽤나 보기싫은 코드가 생겨나게 될 것이다.(많은 loop와 map을 이용한 코드)&lt;/p&gt;
&lt;p&gt;상당히 보기 지저분한 코드가 나올 것이라고 예상할 수 있다. 또한 2중 중첩이 아니라. 3중,4중으로 가게되면 더욱 복잡해질 것이다.&lt;/p&gt;
&lt;p&gt;답은 postgresql의 jsonb 기능이다. postgresql은 groub by 집계함수로 json을 만들어 낼 수가 있다. 이를 통해 결론적으로 nested object를 만들어 바로 반환할 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;postgresql에는 jsonb와 json 타입이 있다. jsonb는 바이너리, json은 텍스트이다. 바이너리로 구성된 jsonb는 내부 값 컨트롤(추가, 수정, 삭제)이 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;해결-과정&#34;&gt;해결 과정&lt;/h1&gt;
&lt;h2 id=&#34;with절-적극-활용하기&#34;&gt;with절 적극 활용하기&lt;/h2&gt;
<<<<<<< HEAD
&lt;p&gt;postgresql에는 with절이라는 것이 있다. with절은 특정 select 구문을 한번 실행하고 임시로 저장해두는 역할을 한다. 비슷한 쿼리를 여러번 실행해야 하는 경우 속도 측면에서 엄청난 강점을 가진다. 이를 보통 &lt;code&gt;CTE(common table expression)&lt;/code&gt;이라고 한다. (&lt;a class=&#34;link&#34; href=&#34;https://fhdufhdu.github.io/post/9&#34; &gt;참고 링크&lt;/a&gt;)&lt;/p&gt;
=======
&lt;p&gt;postgresql에는 with절이라는 것이 있다. with절은 특정 select 구문을 한번 실행하고 임시로 저장해두는 역할을 한다. 비슷한 쿼리를 여러번 실행해야 하는 경우 속도 측면에서 엄청난 강점을 가진다. 이를 보통 &lt;code&gt;CTE(common table expression)&lt;/code&gt;이라고 한다.&lt;/p&gt;
>>>>>>> refs/remotes/origin/main
&lt;h2 id=&#34;대상-게시글-선택&#34;&gt;대상 게시글 선택&lt;/h2&gt;
&lt;p&gt;with절을 활용해 게시글을 조회한다. 해당 게시글 id로 댓글 조회 row 개수를 최소화 하는 목적을 가진다.&lt;/p&gt;
&lt;h2 id=&#34;댓글-선택&#34;&gt;댓글 선택&lt;/h2&gt;
&lt;p&gt;댓글 테이블의 self join을 통해 정책을 sql에 녹여낸다. self join시 row 개수가 많으면 시간이 오래 걸리므로 위의 게시글 조회를 저장해둔 결과를 가져와 댓글 범위를 최소화 한다. 이후 댓글과 유저를 join 한 후 유저 정보를 jsonb로 변환한다. 해당 결과도 with절로 저장해둔다.&lt;/p&gt;
&lt;h2 id=&#34;게시글과-댓글-조합-후-json-제작&#34;&gt;게시글과 댓글 조합 후 json 제작&lt;/h2&gt;
&lt;p&gt;대상 게시글과 댓글 정보를 이용해 join을 맺는다. 이를 통해 &lt;code&gt;게시글-댓글리스트&lt;/code&gt;를 json으로 만들고 전달할 수 있게 된다.&lt;/p&gt;
&lt;h1 id=&#34;후기&#34;&gt;후기&lt;/h1&gt;
&lt;p&gt;해당 쿼리를 게시글 리스트 조회 API와 게시글 상세 조회 API 모두에 사용했다. 같은 쿼리를 사용함으로써 두 API의 데이터를 일관적으로 전달할 수 있었다. 또한 앞서 언급한 jsonb를 이용해서 response dto도 그대로 유지할 수 있었다.&lt;/p&gt;
&lt;p&gt;의외로 추가적인 소득도 있었다. 속도가 &lt;strong&gt;1s에서 200ms 대로 줄었던 것이다.&lt;/strong&gt; with절을 이용한 방식이 효과가 컸던 것 같다. 이번 문제를 해결하기 위해 처음으로 사용해본 것인데, 앞으로도 애용할 것 같다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[PostgreSQL] [실무] Select 쿼리 속도를 개선해 보자</title>
        <link>https://fhdufhdu.github.io/post/7/</link>
        <pubDate>Sun, 07 Jan 2024 20:35:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/7/</guid>
        <description>&lt;h1 id=&#34;문제&#34;&gt; 문제&lt;/h1&gt;
&lt;p&gt;챗봇들의 게시글을 조회하는 데 15초가 걸려버리는 일이 발생했다. 해당 이슈를 듣자마자 바로 SQL 쿼리 문제라는 생각이 들었다. 역시나 예상대로 쿼리가 문제였다.&lt;/p&gt;
&lt;p&gt;정확히 말하면, ORM이 문제였다. 해당 백엔드 서버는 초기 개발을 외주업체에서 진행했는데, 듣자 하니 되게 시간이 촉박했다고 한다. 그래서 그런지 모든 데이터베이스 접근이 ORM으로만 되어 있었다.&lt;/p&gt;
&lt;p&gt;그래서 서버 코드를 인수·인계받고 필자가 제일 먼저 했던 작업이 raw SQL도 사용할 수 있게끔 하는 것이었다.&lt;/p&gt;
&lt;p&gt;이번 문제의 쿼리도 ORM으로 작성된 쿼리였다.&lt;/p&gt;
&lt;p&gt;이제 한번 문제를 살펴보자&lt;/p&gt;
&lt;h2 id=&#34;원인&#34;&gt;원인&lt;/h2&gt;
&lt;p&gt;회사의 특정 쿼리의 결과가 아래와 같았다. 그리고 해당 쿼리에는 select에 서브쿼리가 작성되어 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;c.id&lt;/th&gt;
&lt;th&gt;c.content&lt;/th&gt;
&lt;th&gt;b.id&lt;/th&gt;
&lt;th&gt;l.id&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;ldquo;반가워요&amp;rdquo;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;ldquo;반가워요&amp;rdquo;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;ldquo;반가워요&amp;rdquo;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;ldquo;안녕&amp;rdquo;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;ldquo;안녕&amp;rdquo;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;원하는 결과는 c의 리스트이다. 노출되는 c의 개수는 2개인데, 총 row의 개수는 5개로 뻥튀기된 것을 볼 수 있다. 그렇다면 2번만 서브쿼리를 실행하면 될 것을, 5번이나 실행하고 있었다는 것이다.&lt;/p&gt;
&lt;p&gt;원하는 결과에 c의 갯수가 많아지면 많아 질 수록 row의 개수는 뻥튀기 될 것이다. 만약 20개의 c를 원한다고 하면 100개의 row가 조회될 수도 있고, 100개의 row에 모두 서브쿼리가 실행된다면 20개의 서브쿼리보다 훨씬 느릴 것이다.&lt;/p&gt;
&lt;h1 id=&#34;원인파악-완료-개선해-보자&#34;&gt;원인파악 완료! 개선해 보자&lt;/h1&gt;
&lt;h2 id=&#34;result-row의-갯수를-줄이자&#34;&gt;Result Row의 갯수를 줄이자.&lt;/h2&gt;
&lt;p&gt;ORM 코드를 잘 살펴보니 특정 조건이 빠져있었다. 그래서 필요한 행 말고 모든 행에 대해 join을 걸면서 row의 갯수가 늘어났던 것이었다.&lt;/p&gt;
&lt;p&gt;그 조건을 넣어서 테스트 해봤더니 row의 갯수도 잘 줄어들었고, 15s -&amp;gt; 1s로 속도가 빨라진 것을 확인했다.&lt;/p&gt;
&lt;h1 id=&#34;후기&#34;&gt;후기&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;사실 코드와 테이블 구조를 보여주면서 설명하려고 했지만 회사의 코드여서 그렇게 하지 못했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;생각보다 간단하게 수정되어서 조금은 허탈했다.&lt;/p&gt;
&lt;p&gt;코드의 의도를 읽기 위해서 온갖 시도를 했었는데(실제 코드는 많이 복잡하다.) 의도를 파악하고, 문제를 파악하고 나니, 정말 어이없는 곳에서 문제가 있었던 케이스였던 것 같다.&lt;/p&gt;
&lt;p&gt;이 트러블슈팅 경험으로 인해 ORM에 대한 단점이 더 눈에 들어오더라. ORM이 마냥 좋은 것만은 아니라는 건 체감하고 있었지만, 이번 경험으로 인해 그 생각이 확고히 굳어진 것 같다. SQL, 그리고 DBMS에 대한 이해 없이 ORM만 사용하게 된다면, 좋은 개발자가 될 수 없을 것이라고 생각한다.&lt;/p&gt;
&lt;p&gt;앞으로도 여러 가지 방법을 잘 조합해서 사용해 보도록 해야겠다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[Python] [실무] 커스텀 Router 객체를 만들어 보았다.</title>
        <link>https://fhdufhdu.github.io/post/6/</link>
        <pubDate>Thu, 04 Jan 2024 23:10:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/6/</guid>
        <description>&lt;h1 id=&#34;문제&#34;&gt;문제&lt;/h1&gt;
&lt;p&gt;​
회사에서 필자가 개발한, 멀티 챗봇 시스템에 VOC가 들어오게 되었다. 해당 내용은 &amp;ldquo;가끔 너무 챗봇이 느려요&amp;quot;였다.
​
챗봇 모델 쪽에서 응답이 늦는 경우는 자주 있었기에, 이번에도 그렇겠거니 하고 확인을 해보았다.
​
그런데, 로그에 찍힌 시간을 보니, 모델은 빠른 시간 내에 응답을 해주는 것을 확인했다. 거기서 문제가 있다는 것을 깨닫고, 문제점을 찾아가기 시작했다.
​
문제는 importlib이라는 python 기본 라이브러리가 문제였다. 해당 라이브러리를 사용할 때 간헐적으로 최대 1.8초나 지연되는 현상이 발생했다.
​&lt;/p&gt;
&lt;h2 id=&#34;기존-라우팅-방식&#34;&gt;기존 라우팅 방식&lt;/h2&gt;
&lt;p&gt;​
우선 간략하게 현재 개발 환경을 말하자면 아래와 같다.
​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AWS Lambda(람다)&lt;/li&gt;
&lt;li&gt;AWS Api Gateway&lt;/li&gt;
&lt;li&gt;PostgreSQL&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;웹 프레임워크 사용하지 않음
​&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;챗봇 서버는 웹 프레임워크를 사용하지 않았기에, 챗봇별로 로직을 실행할 때 &lt;code&gt;importlib&lt;/code&gt;이라는 라이브러리를 이용해서 라우팅을 실시했다. &lt;code&gt;importlib&lt;/code&gt;은 동적으로 import를 할 수 있게 도와주는 라이브러리이다.
​
예를 들어 body에 &lt;code&gt;chatbotId&lt;/code&gt;가 &lt;code&gt;Foo&lt;/code&gt;이면 &lt;code&gt;FooFacade&lt;/code&gt; 클래스를 import 해서 쓰거나, &lt;code&gt;Bar&lt;/code&gt;이면 &lt;code&gt;BarFacade&lt;/code&gt; 클래스를 import해서 쓰거나 하는 식으로 진행했다.
​
그런데 &lt;code&gt;importlib&lt;/code&gt;이 느리다니&amp;hellip; 이해가 되지 않았다. &lt;code&gt;importlib&lt;/code&gt;은 결국 &lt;code&gt;__import__&lt;/code&gt; 함수의 래퍼이다. &lt;code&gt;__import__&lt;/code&gt;함수는 import 구문을 만나면 실행되는 기본적인 함수이다. 이게 느리다면, 파이썬을 사용해도 되는 것일까?
​&lt;/p&gt;
&lt;h2 id=&#34;import의-작동-방식에-대해서-알아보자&#34;&gt;Import의 작동 방식에 대해서 알아보자&lt;/h2&gt;
&lt;p&gt;​
해당 정보는 &lt;a class=&#34;link&#34; href=&#34;https://medium.com/@likegondry/python-til-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%B4-import%EB%A1%9C-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%84-%EB%B6%88%EB%9F%AC%EC%98%A4%EB%8A%94-%EB%B0%A9%EB%B2%95-76e268e7613b&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;김지연 님의 블로그&lt;/a&gt;를 참고해서 작성했다.
​&lt;/p&gt;
&lt;h2 id=&#34;1-sysmodule에-모듈이-존재하는지-찾아보기&#34;&gt;1. sys.module에 모듈이 존재하는지 찾아보기&lt;/h2&gt;
&lt;p&gt;​
sys.module에는 이때까지 사용했던 module들이 딕셔너리 형태로 저장되어 있다. import시 해당 모듈이 이전에 import 된 것이라면 빠르게 가져올 수 있다.
​&lt;/p&gt;
&lt;h2 id=&#34;2-syspath에-저장된-파일-목록들-하나하나-찾아보기&#34;&gt;2. sys.path에 저장된 파일 목록들 하나하나 찾아보기&lt;/h2&gt;
&lt;p&gt;​
이 작업이 좀 오래 걸린다. 파일 리스트을 하나하나 탐색하면서 모듈을 가져오기 때문에 시간이 오래걸린다. 아마 필자의 생각으로는 File I/O 작업이라서 오래 걸리는 것 같다.
​&lt;/p&gt;
&lt;h2 id=&#34;그럼-동적으로-import-하는-것은&#34;&gt;그럼 동적으로 import 하는 것은&amp;hellip;?&lt;/h2&gt;
&lt;p&gt;​
만약 &lt;code&gt;FooFacade&lt;/code&gt; 클래스를 &lt;strong&gt;처음&lt;/strong&gt; 동적으로 import 한다면, 생각보다 시간이 오래 걸릴 수 있겠다는 생각이 들었다. 실제로도 처음 실행할 때와, 조금 유휴시간이 지난 후 실행하면 &lt;code&gt;importlib&lt;/code&gt; 동작 시간이 오래 걸리는 것을 확인할 수 있었다.
​
심지어 AWS 람다를 이용하고 있어서, 일정 유휴시간이 지나면 컨테이너가 내려가버린다. 그렇다면 새롭게 컨테이너가 생성될 때마다, &lt;code&gt;importlib&lt;/code&gt;에서 시간을 많이 잡아먹었다.
​&lt;/p&gt;
&lt;h1 id=&#34;해결방법&#34;&gt;해결방법&lt;/h1&gt;
&lt;p&gt;​
이제 문제점을 찾았으니 해결을 해보자.
​
결국 라우팅의 문제였으니, 이 라우팅을 다른 방식으로 하면 되지 않을까?
​
그래서 유명한 파이썬 웹 프레임워크인 FastAPI의 &lt;a class=&#34;link&#34; href=&#34;https://github.com/tiangolo/fastapi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;깃허브 소스&lt;/a&gt;를 뜯어보았다.
​
FastAPI는 어떻게 라우팅을 사용하고 있을까?
​&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from fastapi import APIRouter, FastAPI
​
app = FastAPI()
internal_router = APIRouter()
users_router = APIRouter()
​
@users_router.get(&amp;#34;/users/&amp;#34;)
def read_users():
    return [{&amp;#34;name&amp;#34;: &amp;#34;Rick&amp;#34;}, {&amp;#34;name&amp;#34;: &amp;#34;Morty&amp;#34;}]
​
internal_router.include_router(users_router)
app.include_router(internal_router)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​
이런 식으로 &lt;code&gt;APIRouter&lt;/code&gt; 객체를 하나 생성하고, APIRouter 객체의 &lt;code&gt;get&lt;/code&gt;(&lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &amp;hellip;) 함수를 라우팅 하고자 하는 함수에 데코레이터로 붙여준다. 그리고 &lt;code&gt;app&lt;/code&gt; 객체에 해당 라우터를 전달한다.
​
이후 http 요청이 들어오면 &lt;code&gt;app&lt;/code&gt; 객체로 전달되고, &lt;code&gt;app&lt;/code&gt; 객체는 라우팅 정보를 확인해서 해당 함수를 실행한다.
​
자 어떻게 이것이 가능할까.
​
필자의 생각은 아래와 같았다.
​&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;APIRouter&lt;/code&gt; 객체는 멤버 함수로 데코레이터로 사용가능한 함수를 가지고 있다.(ex. &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;데코레이터 함수는 자기가 붙은 함수를 객체 형태로 사용할 수 있다.&lt;br&gt;
(ex. &lt;code&gt;user_router&lt;/code&gt;의 get 함수는 &lt;code&gt;read_users&lt;/code&gt; 함수를 객체형태로 사용가능)&lt;/li&gt;
&lt;li&gt;그렇다면 get을 호출하면, &lt;code&gt;read_users&lt;/code&gt; 같은 함수를 &lt;code&gt;users_router&lt;/code&gt;에 딕셔너리 형태로 저장하면 되겠네?&lt;br&gt;
(ex. &lt;code&gt;{&amp;quot;users&amp;quot;: read_user}&lt;/code&gt; 와 같은 형태로)&lt;/li&gt;
&lt;li&gt;맞는 것 같은데&amp;hellip; 한번 확인해 볼까?
​
&lt;code&gt;APIRouter&lt;/code&gt;의 &lt;code&gt;get&lt;/code&gt; 함수를 보면 &lt;code&gt;self.api_route(...)&lt;/code&gt;를 호출하고 해당 결괏값을 바로 반환한다.
​
그렇다면 &lt;code&gt;api_route&lt;/code&gt; 함수를 보자.
​&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 너무 길어서 간략하게 축소한 버전이다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;api_route&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        path: str,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Callable[[DecoratedCallable], DecoratedCallable]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decorator&lt;/span&gt;(func: DecoratedCallable) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; DecoratedCallable:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add_api_route(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                path,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                func,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; func
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; decorator
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​
해당 함수를 보게 되면, &lt;code&gt;user_router.get&lt;/code&gt;이 &lt;code&gt;read_users&lt;/code&gt;에 데코레이터로 붙게 되는 순간 &lt;code&gt;func&lt;/code&gt; 파라미터에 &lt;code&gt;read_users가&lt;/code&gt; 들어오게 된다. 이후 &lt;code&gt;self.add_api_route&lt;/code&gt;를 호출하는데, 이때 아래와 같은 코드가 실행된다.
​&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_api_route&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        path: str,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        endpoint: Callable[&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;, Any],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        생략
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        route &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; route_class(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;prefix &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; path,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            endpoint&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;endpoint,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            생략
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;routes&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(route)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​
path는 &amp;ldquo;/user/&amp;rdquo;, endpoint는 &lt;code&gt;read_users&lt;/code&gt; 함수이다. 이 두 가지를 통해 &lt;code&gt;route&lt;/code&gt; 객체를 하나 만들고 이를 &lt;code&gt;user_routes의&lt;/code&gt; &lt;code&gt;routes&lt;/code&gt; 리스트에 추가한다.
​
필자가 생각한 3번 과정은 아니고, 리스트 탐색으로 라우팅을 하는 것이지만, 어찌 됐든 비슷하다고 생각했다.
​
그리고 path param을 생각하면 딕셔너리의 key, value 탐색보다 리스트 탐색이 더 낫다고 생각이 든다.(path param이 들어가면 어쨌든 n만큼 순회해야 하니까!)&lt;/p&gt;
&lt;p&gt;​
필자의 생각이 어느 정도 맞다는 걸 인지했으니 신나게 Router 객체를 제작해서 만들었다.
(아쉽게도 회사의 코드는 공개할 수 없으므로 비슷하게도 공개할 수 없다..)
​&lt;/p&gt;
&lt;h1 id=&#34;결과&#34;&gt;결과&lt;/h1&gt;
&lt;p&gt;​
무려 라우팅시 1.8초나 걸리던 것이 0.001초 미만에 해결되는 모습을 보였다. 해당 코드를 만들고 동료 개발자와 코드리뷰 때 &amp;ldquo;어떻게 이런 생각을 했냐&amp;quot;라고 하셔서 되게 기분이 좋았다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[JS] 이벤트 루프와 비동기 함수</title>
        <link>https://fhdufhdu.github.io/post/5/</link>
        <pubDate>Wed, 03 Jan 2024 23:34:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/5/</guid>
        <description>&lt;p&gt;오늘은 JS의 비동기에 대해 설명해보고자 한다.&lt;/p&gt;
&lt;p&gt;JS에 대해 잘 모르고 비동기에 대한 개념이 희박하던 때, 단순히 콜백함수가 비동기 함수인 줄 알았다.&lt;/p&gt;
&lt;p&gt;하지만 단순히 콜백함수를 만든다고 해서 비동기적으로 작동하는 것은 아니다. 모든 JS의 비동기는 이벤트 루프에 등록되어야 한다.&lt;/p&gt;
&lt;p&gt;조금 더 자세히 알아보자.&lt;/p&gt;
&lt;p&gt;동기와 비동기 작업에 대해 알아보고 싶다면 아래 게시글을 참고하자.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;%7b%7bsite.baseurl%7d%7d/cs-%eb%8f%99%ea%b8%b0%eb%b9%84%eb%8f%99%ea%b8%b0%ec%97%90%eb%8c%80%ed%95%b4%ec%84%9c%ec%95%8c%ec%95%84%eb%b3%b4%ec%9e%90/&#34; &gt;2024.01.02 - [CS] - [CS] 동기/비동기에 대해서 알아보자(sync/async)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;콜백-함수는-동기이다&#34;&gt;콜백 함수는 동기이다.&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;callback&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;callback&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;) =&amp;gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;============================&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;count 함수는 파라미터 num에 10번 반복문을 돌면서 1을 더하는 함수이다. 그리고 for가 끝나면 콜백을 실행한다.&lt;/p&gt;
&lt;p&gt;해당 코드를 실행하면 아래와 같은 결과가 나온다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; 11
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;============================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1001&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1002&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1003&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1004&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1005&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1006&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1007&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1008&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1009&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1010&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;완벽하게 동기로 실행되는 것을 볼 수 있다. 그러므로 콜백함수를 만든다고 해서 비동기로 작동하지 않는다.&lt;/p&gt;
&lt;h1 id=&#34;그럼-비동기는-어떤-함수가-사용되는가&#34;&gt;그럼 비동기는 어떤 함수가 사용되는가?&lt;/h1&gt;
&lt;h2 id=&#34;우선-이벤트-루프에-대해-이해해-보자&#34;&gt;우선 이벤트 루프에 대해 이해해 보자&lt;/h2&gt;
&lt;p&gt;JS는 싱글 스레드로 작동한다. 이 싱글 스레드에서 비동기를 가능하게 해주는 것이 바로 WEB API와 이벤트 루프이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(()=&amp;gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)}, &lt;span style=&#34;color:#ae81ff&#34;&gt;4000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(()=&amp;gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)}, &lt;span style=&#34;color:#ae81ff&#34;&gt;2000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(()=&amp;gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)}, &lt;span style=&#34;color:#ae81ff&#34;&gt;3000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(()=&amp;gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)}, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;해당 코드의 결과는 아래와 같다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/fhdufhdu/fhdufhdu.github.io/assets/32770312/c8fcbf83-d788-4ab8-870c-b1eb88fc6002&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;완벽하게 비동기로 작동하는 것이 보인다. 그렇다면 실행 순서를 알아보자&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;setTimeout(()=&amp;gt;{console.log(1)}, 4000)&lt;/code&gt; 실행, WEB API에서 4초 타이머가 작동함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTimeout(()=&amp;gt;{console.log(2)}, 2000)&lt;/code&gt; 실행, WEB API에서 2초 타이머가 작동함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTimeout(()=&amp;gt;{console.log(3)}, 3000)&lt;/code&gt; 실행, WEB API에서 3초 타이머가 작동함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTimeout(()=&amp;gt;{console.log(4)}, 1000)&lt;/code&gt; 실행, WEB API에서 1초 타이머가 작동함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;console.log(5)&lt;/code&gt; 실행 -&amp;gt; 5가 출력됨&lt;/li&gt;
&lt;li&gt;모든 코드가 마무리되었으므로, WEB API를 확인해서 비동기 작업이 끝난 것이 있는지 확인.&lt;/li&gt;
&lt;li&gt;1초 후 WEB API에서 비동기 작업이 끝난 것을 확인. &lt;code&gt;()=&amp;gt;{console.log(4)}&lt;/code&gt; 함수를 이벤트 루프의 큐에 삽입.&lt;/li&gt;
&lt;li&gt;이벤트 루프에서 콜백 함수를 가져와서 콜스택에 추가 -&amp;gt; 콜스택 실행 -&amp;gt; 4가 출력됨&lt;/li&gt;
&lt;li&gt;2초 후 WEB API에서 비동기 작업이 끝난 것을 확인. &lt;code&gt;()=&amp;gt;{console.log(2)}&lt;/code&gt; 함수를 이벤트 루프의 큐에 삽입&lt;/li&gt;
&lt;li&gt;8번과 작업 동일&lt;/li&gt;
&lt;li&gt;3초 후 WEB API에서 비동기 작업이 끝난 것을 확인. &lt;code&gt;()=&amp;gt;{console.log(3)}&lt;/code&gt; 함수를 이벤트 루프의 큐에 삽입&lt;/li&gt;
&lt;li&gt;8번과 작업 동일&lt;/li&gt;
&lt;li&gt;4초 후 WEB API에서 비동기 작업이 끝난 것을 확인. &lt;code&gt;()=&amp;gt;{console.log(1)}&lt;/code&gt; 함수를 이벤트 루프의 큐에 삽입&lt;/li&gt;
&lt;li&gt;8번과 작업 동일&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여기서 JS는 싱글 스레드인데 WEB API는 멀티 스레드처럼 작동하는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;그것이 맞다. JS는 싱글 스레드에서 작동하지만, &lt;strong&gt;WEB API는 다른 곳&lt;/strong&gt;(ex. 커널)&lt;strong&gt;에게 작업을 위임&lt;/strong&gt;한다.&lt;/p&gt;
&lt;p&gt;그래서 위의 타이머 작동은 JS에서 작동하는 것이 아닌, 다른 곳에서 작동하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이후 타이머 작동이 끝나면, JS의 이벤트 루프에게 콜백을 전달하고, 이벤트 루프는 콜스택이 비워져 있을 때 이벤트 루프에 쌓인 콜백을 콜스택으로 전달해서 콜백 함수를 실행한다.&lt;/strong&gt;(7~14번 작업)&lt;/p&gt;
&lt;p&gt;이벤트 루프는 비동기 작업을 처리하는 곳이 아니다. &lt;strong&gt;이벤트 루프는 비동기 작업이 끝난 후 실행되어야 할 콜백들이 저장된 곳이다. 실질적인 비동기 작업은 WEB API에서 처리된다.&lt;/strong&gt; 또한 이벤트 루프는 WEB API와 다르게 JS에서 작동하는 것이기 때문에 비동기 작업을 할 수 없다.&lt;/p&gt;
&lt;p&gt;아래 GIF를 보면 더욱 이해가 잘 될 것이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fhdufhdu.github.io/post/5/event-loop.gif&#34;
	width=&#34;720&#34;
	height=&#34;405&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;비동기가-되기-위한-조건&#34;&gt;비동기가 되기 위한 조건&lt;/h2&gt;
&lt;p&gt;자, 위에서 이벤트 루프에 대해 알아보았다. 위에서 이벤트 루프는 비동기가 끝난 후 실행되어야 할 콜백 함수들이 저장된 곳이라고 말해주었다. 또한, 실질적인 비동기 작업은 WEB API에서 처리된다는 것도 알게 되었다.&lt;/p&gt;
&lt;p&gt;그렇다면 WEB API에 작업을 위임할 수 있는 것에는 무엇이 있을까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O 작업 (File, Network)&lt;/li&gt;
&lt;li&gt;Timer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아까 말했다시피 WEB API는 다른 곳에서 작업을 수행한다. 그렇기에 해당 작업을 수행하는 동안 JS는 놀고 있게 되고, 이는 싱글스레드에서 비동기가 가능하게 되는 이유다.&lt;/p&gt;
&lt;h1 id=&#34;정리&#34;&gt;정리&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;콜백을 사용한다고 모두 비동기가 되는 것이 아니다.&lt;/li&gt;
&lt;li&gt;JS는 싱글 스레드이다. 일반적으로 싱글 스레드에서는 비동기가 불가능하다.&lt;/li&gt;
&lt;li&gt;이를 가능하게 해주는 것이 WEB API와 이벤트 루프이다.&lt;/li&gt;
&lt;li&gt;WEB API는 JS가 아닌 다른 곳에서 실행된다.&lt;/li&gt;
&lt;li&gt;이벤트 루프는 JS의 일부이다.(=JS에서 실행된다)&lt;/li&gt;
&lt;li&gt;이벤트 루프는 비동기 작업(=WEB API 작업)이 끝난 후 실행될 콜백 함수가 저장된 곳이다.&lt;/li&gt;
&lt;li&gt;WEB API에서 실행가능한 작업의 종류에는 I/O작업과 Timer가 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>[CS] 동기/비동기에 대해서 알아보자(sync/async)</title>
        <link>https://fhdufhdu.github.io/post/4/</link>
        <pubDate>Tue, 02 Jan 2024 22:15:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/4/</guid>
        <description>&lt;p&gt;오늘은 동기와 비동기에 대해서 설명하고자 한다.&lt;/p&gt;
&lt;p&gt;해당 개념은 설명만 들으면 쉽게 이해가 될 수도 있지만, 헷갈릴 여지도 많은 개념이라고 생각한다.&lt;/p&gt;
&lt;p&gt;특히 스레드 개념과 엮이기 시작하면 많이 헷갈리기 시작하는 개념이다.&lt;/p&gt;
&lt;h1 id=&#34;동기sync&#34;&gt;동기(Sync)&lt;/h1&gt;
&lt;p&gt;동기가 제일 간단하다. 흔히 우리가 쓰는 코드를 상상하면 된다.&lt;/p&gt;
&lt;p&gt;아래 JS 예제가 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 결과는 위에서부터 순차적으로 실행되어 아래와 같은 결과를 보일 것이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fhdufhdu.github.io/post/4/image.png&#34;
	width=&#34;210&#34;
	height=&#34;216&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;코드 결과&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;97&#34;
		data-flex-basis=&#34;233px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;비동기async&#34;&gt;비동기(Async)&lt;/h1&gt;
&lt;p&gt;자 이제 비동기에 대해 이해해 보자. 단순하게 비동기는 동기의 반대말이다. 동기가 순차적으로 실행되는 것을 의미하니까 비동기는 순차적으로 실행되지 않는다고 생각하면 된다. 순차적으로 실행되지 않는다면, 코드의 실행순서를 파악하기 힘들 것이다. 이렇게 생각했을 때 비동기가 정말 필요한지에 대해 의문점이 생긴다.&lt;/p&gt;
&lt;h2 id=&#34;비동기의-필요성&#34;&gt;비동기의 필요성&lt;/h2&gt;
&lt;p&gt;비동기가 등장한 이유는 낭비되는 시간이 아까워서이다. 아래와 같은 코드를 보자&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 해당 코드는 psuedo 코드이다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reqBody&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;choding&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;is good&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;requests&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;post&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:3000&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;reqBody&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 이후 필요한 로직 실행!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;단순하게 http 요청을 보내는 코드이다. 이 코드가 동기적으로 작동한다면 대락 100초 이후에 console.log(response.body)가 실행되고 이후 로직이 작동할 것이다. 근데 http 요청을 보내고, 받는 100초 동안 프로세스는 무엇을 하고 있을까?&lt;/p&gt;
&lt;p&gt;정답은 &lt;strong&gt;&amp;ldquo;아무것도 안하고 있다.&amp;rdquo;&lt;/strong&gt; 이다. 정말 아무것도 안 하고 http 응답을 받는 순간까지 기다리는 것만 진행할 것이다. 만약 이 100초라는 시간에 다른 작업을 하면 어떨까? 웬만하면 많은 작업들을 처리할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;이 남는 시간을 활용하기 위해 비동기라는 개념이 등장했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fhdufhdu.github.io/post/4/image-1.png&#34;
	width=&#34;1440&#34;
	height=&#34;554&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;비동기 작동 과정&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;259&#34;
		data-flex-basis=&#34;623px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;위 그림처럼, 2번이 완료되지 않았음에도, 2번의 응답이 오기까지의 시간동안 다른 작업을 하는 것이 바로 비동기라고 할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;콜백&#34;&gt;콜백&lt;/h2&gt;
&lt;p&gt;앞서 비동기의 필요성을 말했다. 그렇다면 100초 동안 비는 시간에 다른 작업을 하고 나서, 응답을 받는 순간에는 어떻게 될까? 해당 값으로 처리하는 로직이 필요할 것이다. 그것이 바로 콜백(callback)이다.&lt;/p&gt;
&lt;p&gt;콜백의 주요 논지는 &lt;strong&gt;&amp;ldquo;해야할 일을 뒤로 미루는 것&amp;rdquo;&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;p&gt;사실, 이름만 봐도 알 수 있다. callback은 회신하다/답신하다는 뜻이다.&lt;/p&gt;
&lt;p&gt;그러니까 &amp;ldquo;할일 다 하고(=해야 할 일 미루고), 네가 요청한 일 처리할 수 있을 때 처리하겠다&amp;quot;라는 것이다.&lt;/p&gt;
&lt;p&gt;아래 코드를 다시 보자.&lt;/p&gt;
&lt;p&gt;2번 과정이 100초가 걸리니까, 2번의 응답이 오는 100초 동안 다른 일을 JS가 한다고 하자. 이후 100초가 지난 후, 2번의 응답을 가지고 무언가 작업을 해야 할 것이다. 그런데, 어떻게 실행할 것인가? &lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 해당 코드는 psuedo 코드이다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reqBody&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;choding&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;is good&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;requests&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;post&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:3000&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;reqBody&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 이후 필요한 로직 실행!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//100초 후...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//어라, 어떻게 응답을 처리하지?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//응답은 왔는데.... 처리할 코드를 어떻게 작성하지...?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이때 콜백을 작성하면 응답을 처리할 수 있는 코드를 작성할 수 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 해당 코드는 psuedo 코드이다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reqBody&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;choding&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;is good&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;requests&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;post&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:3000&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;reqBody&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 4. 100초 후 이 함수 실행
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 처럼 콜백 함수를 작성할 수 있을 것이다. 저 4번 콜백 함수는 http 응답이 오면 실행된다.&lt;/p&gt;
&lt;p&gt;4번의 콜백 함수는 앞서 말한 &lt;strong&gt;&amp;ldquo;해야 할 일을 뒤로 미루는 것&amp;quot;과&lt;/strong&gt; 같다.&lt;/p&gt;
&lt;h1 id=&#34;마무리&#34;&gt;마무리&lt;/h1&gt;
&lt;p&gt;간단하게 비동기와 콜백에 대해 알아보았다.&lt;/p&gt;
&lt;p&gt;이렇게 보면 비동기 자체는 크게 어렵지 않은 것 같다. 하지만 필자도 이 개념을 오해 없이 이해하기에 많은 시간이 들었다.&lt;/p&gt;
&lt;p&gt;여러분들도 오해없이 비동기를 이해할 수 있게 되었으면 좋겠다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[Docker] 컨테이너를 Docker Hub에 올리기</title>
        <link>https://fhdufhdu.github.io/post/3/</link>
        <pubDate>Wed, 20 Dec 2023 12:39:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/3/</guid>
        <description>&lt;p&gt;Docker 컨테이너를 그대로 이미지로 만들어서 Docker Hub에 올리고 싶다면 아래와 같이 진행하자.&lt;/p&gt;
&lt;h1 id=&#34;docker-hub-로그인하기&#34;&gt;Docker Hub 로그인하기&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker Hub&lt;/a&gt;에 들어가서 로그인을 먼저 한다. 회원가입을 진행하지 않았다면 회원가입을 먼저 하자.&lt;/p&gt;
&lt;p&gt;개인 Docker Hub Repository에 이미지를 올리기 때문에 로그인은 필수다.&lt;/p&gt;
&lt;p&gt;회원가입을 하고 나면 플랜을 선택하라는 화면이 나올 수 있는데, 이때 Personal 플랜으로 진행하면 된다.(무료)&lt;/p&gt;
&lt;h1 id=&#34;repository-만들기&#34;&gt;Repository 만들기&lt;/h1&gt;
&lt;p&gt;로그인을 하고나서 메인화면에서&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fhdufhdu.github.io/post/3/image.png&#34;
	width=&#34;2552&#34;
	height=&#34;292&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;도커 허브 웹페이지&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;873&#34;
		data-flex-basis=&#34;2097px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;위 이미지와 같이 Repository -&amp;gt; Create Repository를 눌러준다.&lt;/p&gt;
&lt;p&gt;정보 입력 후 Repostiory를 생성하게 되면 자신의 Repository 화면으로 들어갈 수 있게 된다.&lt;/p&gt;
&lt;h1 id=&#34;컨테이너-commit-하기&#34;&gt;컨테이너 commit 하기&lt;/h1&gt;
&lt;p&gt;현재 자신의 컴퓨터에 존재하는 컨테이너를 image화 하는 과정이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ docker commit 자신의컨테이너이름 repository경로:tag
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 실제 입력 예&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# tag(=version)는 본인 전략대로 사용하기&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ docker commit es fhdufhdu/test_elasticsearch:1.0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;생성된-이미지를-업로드하기&#34;&gt;생성된 이미지를 업로드하기&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 로그인, username에 email은 입력하지 말기&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ docker login
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#이미지 이름에 있는 repository로 이미지가 업로드되게 된다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ docker push fhdufhdu/mim_elasticsearch:1.0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;The push refers to repository &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;docker.io/fhdufhdu/mim_elasticsearch&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ec8582fc54e5: Pushed 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bca54c335b28: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;de080e772c1a: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cfc1ead7498a: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;245d80f411fb: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;489e330647ba: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cff7c30e604c: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3a50035e8665: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;7074040eb2b7: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;af7ed92504ae: Mounted from library/elasticsearch 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1.0: digest: sha256:018de9cde96f6304cb8967a5747fe123244af76ef502fd7c5e446dd91b6aa765 size: &lt;span style=&#34;color:#ae81ff&#34;&gt;2417&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 명령어를 실행하면, 이미지를 Repository에 올릴 것이다.&lt;/p&gt;
&lt;p&gt;이후 이미지를 받아와서 컨테이너에 올리는 작업은 기존 방식과 동일하게 진행하면 된다.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[Python] 추상 클래스 만들기</title>
        <link>https://fhdufhdu.github.io/post/2/</link>
        <pubDate>Wed, 20 Dec 2023 12:16:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/2/</guid>
        <description>&lt;h1 id=&#34;추상-클래스-만들기&#34;&gt;추상 클래스 만들기&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; abc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BaseClass&lt;/span&gt;(metaclass&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;abc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ABCMeta):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@abc.abstractmethod&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 아래처럼 &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BaseClass&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    __metaclass__ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; abc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ABCMeta
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@abc.abstractmethod&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ChildClass&lt;/span&gt;(BaseClass):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello world!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ChildClass()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위와 같이 &lt;code&gt;metaclass&lt;/code&gt;로 해당 클래스가 추상 클래스라는 것을 명시한다.&lt;/p&gt;
&lt;p&gt;이후 추상클래스로 쓰고 싶은 메서드에 &lt;code&gt;abstractmethod&lt;/code&gt; 데코레이터를 달면 된다.&lt;/p&gt;
&lt;p&gt;만약 상속받는 클래스에서 추상클래스를 구현하지 않으면 아래와 같이 에러가 뜬다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Traceback &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;most recent call last&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  File &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/var/task/main.py&amp;#34;&lt;/span&gt;, line 12, in &amp;lt;module&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ChildClass&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TypeError: Can&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;t instantiate abstract class ChildClass with abstract method run
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>[개발방법론] 객체 지향과 절차 지향에 대해 알아보자</title>
        <link>https://fhdufhdu.github.io/post/1/</link>
        <pubDate>Wed, 20 Dec 2023 11:14:00 +0900</pubDate>
        
        <guid>https://fhdufhdu.github.io/post/1/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;개발을 막 시작한 새내기 개발자부터 개발 경력이 많은 개발자까지 무조건 들어봤을 용어, 객체 지향에 대해 알아보자.&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;자동차 운전을 코드로 구현하는 것을 예시로, 객체 지향과 절차 지향을 비교해 가면서 설명한다. 객체 지향을 배우러 왔는데, 절차 지향까지 알아야 한다고 겁먹지 말자, 절차 지향을 이해한다면, 객체 지향을 이해하기 더욱 쉬울 것이다.&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;이 내용은 기본적인 코드 작성 지식이 있어야 이해할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;절차-지향과-객체-지향&#34;&gt;절차 지향과 객체 지향&lt;/h1&gt;
&lt;h2 id=&#34;절차-지향이란&#34;&gt;절차 지향이란?&lt;/h2&gt;
&lt;p&gt;객체지향이 있기 이전, 개발 패러다임은 절차 지향이었다. 절차 지향은 간단히 &amp;ldquo;어떤 일을 하기 위해 필요한 행동들의 나열&amp;rdquo; 이라고 정의할 수 있다. 아래와 같은 코드 예제를 보자&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    direction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 어느 방향으로 돌릴 것 인가요?(left, right): &amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; direction &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 오른쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 왼쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;사용자에게 핸들 방향을 입력받고, 해당 방향에 맞게 핸들을 돌렸다고 출력해 주는 코드이다.&lt;/p&gt;
&lt;p&gt;이와 같이, &amp;ldquo;핸들을 꺾기 위해(어떤 일) 사용자의 입력을 받고, 입력에 맞게 문자열을 출력하는 코드 (행동들의 나열)&amp;ldquo;로 볼 수 있는 것이 절차 지향적인 코드 작성 방법이다.&lt;/p&gt;
&lt;h2 id=&#34;객체-지향이란&#34;&gt;객체 지향이란?&lt;/h2&gt;
&lt;p&gt;객체 지향은 절차지향의 정의인 &amp;ldquo;어떤 일을 하기 위해 필요한 행동들의 나열&amp;quot;을 확장해서 &amp;ldquo;어떤 일을 하기 위한 객체들의 상호작용&amp;quot;으로 정의할 수 있다. 아래와 같은 코드 예제를 보자&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Car&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chagne_direction&lt;/span&gt;(self, direction: string):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; direction &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 오른쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 왼쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    direction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 어느 방향으로 돌릴 것 인가요?(left, right): &amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    car &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Car()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    car&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;chagne_direction(direction)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;우선 Car라는 클래스를 만든다. 해당 클래스에서는 자동자의 &amp;ldquo;행동&amp;quot;과 관련된 모든 것을 다룬다. 여기에서는 방향전환 행동만을 추가했다.&lt;/p&gt;
&lt;p&gt;그리고 절차 지향에서의 코드와 같이 사용자에게 입력을 받고, 해당 입력을 저장해 둔다.&lt;/p&gt;
&lt;p&gt;이후, Car(클래스)에서 car(인스턴스)를 만들고, car(인스턴스)의 change_direction을 실행해서 핸들을 전환하도록 한다.&lt;/p&gt;
&lt;p&gt;이와 같이 자동차라는 개념적인 그룹으로 묶어서 코드를 작성하는 방식을 객체 지향 개발이라고 한다.&lt;/p&gt;
&lt;h1 id=&#34;클래스와-인스턴스&#34;&gt;클래스와 인스턴스&lt;/h1&gt;
&lt;p&gt;클래스/인스턴스는 처음 마주했을 때 이해하기 쉽지 않은 용어이다.&lt;/p&gt;
&lt;p&gt;자동차를 예로 들어보자.&lt;/p&gt;
&lt;p&gt;자동차는 어떤 것인가? 명확히 정의하긴 어렵지만, 바퀴 4개(혹은 더 여러 개), 엔진, 핸들이 있는 탈 것이라고 할 수 있다. 이런 개념적인 것들을 가진 모든 것들을 자동차라고 부를 수 있다. 이렇게 보면, 완전히 추상적인 개념이라고 볼 수 있다. 이런 것들을 클래스라고 한다.&lt;/p&gt;
&lt;p&gt;우리가 실제 이용하는 자동차들은 무엇이 있을까. 나의 산타페, 다른 사람의 산타페, 602-1A번 버스 등 많은 자동차들이 있다. 이런 것들을 인스턴스라고 한다.&lt;/p&gt;
&lt;p&gt;자동차라는 &amp;ldquo;개념&amp;quot;만 가지고는 행동을 할 수 없지만, 산타페라는 실체를 가지고는 운전을 할 수 있다. 이처럼 행동을 할 수 있도록 클래스에서 객체를 만들어서 사용한다.&lt;/p&gt;
&lt;p&gt;아래와 같은 코드 예제를 보자&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Car&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chagne_direction&lt;/span&gt;(self, direction: string):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; direction &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 오른쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 왼쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# car1과 car2는 Car에서 생성된 두개의 다른 실체임&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    car1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Car()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    car2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Car()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 코드는 Car클래스에서 두 개의 인스턴스를 생성한다.&lt;br&gt;
다르게 이야기하면, 하나의 Car라는 추상적인 개념에서 두 대의 실제 자동차를 생성한 것이고, 이 자동차들을 각자 개별적으로 움직일 것이다.&lt;/p&gt;
&lt;p&gt;정리하자면,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클래스는 &amp;ldquo;어떤 행동을 하는 추상적인 개념 - 자동차, 사람&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**인스턴스는 &amp;ldquo;실제로 그 행동을 하는 실체 - 산타페(자동차), 나 자신(사람), 여러분들(사람)&amp;rdquo;**으로 정리할 수 있겠다.&lt;/p&gt;
&lt;h1 id=&#34;객체와의-상호작용&#34;&gt;객체와의 상호작용&lt;/h1&gt;
&lt;p&gt;이번엔 객체 지향 프로그래밍의 본질인, 객체와의 상호작용을 알아보자.&lt;/p&gt;
&lt;p&gt;이번에도 코드 예제를 보도록 하자.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Wheel&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;change_direction&lt;/span&gt;(self, direction: string):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; direction &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;바퀴를 오른쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;바퀴를 왼쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Car&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;wheel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Wheel()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chagne_direction&lt;/span&gt;(self, direction: string):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; direction &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 오른쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 왼쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;wheel&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;change_direction(direction)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    direction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 어느 방향으로 돌릴 것 인가요?(left, right): &amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    car &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Car()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    car&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;chagne_direction(direction)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;main 함수는 위의 예제와 같다.&lt;/p&gt;
&lt;p&gt;이번에 추가된 것은 Wheel의 존재다. 잘 생각해 보면, 자동차는 바퀴가 있어야 굴러갈 것이다. 그리고 사용자가 핸들을 돌리면 바퀴가 돌아가야 할 것이다. 그러므로 Car는 Wheel을 가지고 있어야 한다. (이것을 has-a 관계라고 하는데, 이 부분은 나중에 설명하겠다)&lt;/p&gt;
&lt;p&gt;그래서 위의 예제는 사용자가 핸들을 돌리면 바퀴도 같이 돌아가는 예제이다.&lt;/p&gt;
&lt;p&gt;Car는 처음 생성될 때, Wheel을 생성해서 자신이 가지고 있고, 사용자가 핸들을 돌리면, Car는 Wheel의 방향을 변경한다.&lt;/p&gt;
&lt;p&gt;이렇게 보면 Car와 Wheel이 상호작용하고 있는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;만약 절차 지향적인 코드였다면 어땠을까? &lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    direction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 어느 방향으로 돌릴 것 인가요?(left, right): &amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; direction &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 오른쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;바퀴를 오른쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    	print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;핸들을 왼쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;바퀴를 왼쪽으로 전환!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위와 같이 끝났을 것이다.&lt;/p&gt;
&lt;p&gt;어라 근데 여기서 이상한 점이 보인다.&lt;/p&gt;
&lt;h1 id=&#34;절차-지향이-더-좋아-보이는데&#34;&gt;절차 지향이 더 좋아 보이는데&amp;hellip;?&lt;/h1&gt;
&lt;p&gt;필자가 제시한 예제를 보면, 절차지향적인 코드가 훨씬 짧고 간결해 보이고, 이해하기도 쉬워 보인다.&lt;/p&gt;
&lt;p&gt;하지만 다들 실제로 객체지향적으로 구현을 하고 있다.&lt;/p&gt;
&lt;p&gt;이유가 뭘까?&lt;/p&gt;
&lt;p&gt;이유는 &lt;strong&gt;재사용성&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;만약 자동차가 100대가 동시에 움직인다면?&lt;/p&gt;
&lt;p&gt;저 if-else 부분을 100번 돌리는 것이 좋을까? Car를 100개 만드는 게 좋을까?&lt;/p&gt;
&lt;p&gt;직관적으로 봤을 때, Car를 100개 만드는 것이 다른 사람이 볼 때 더욱 이해하기가 쉽지 않을까?&lt;/p&gt;
&lt;p&gt;하지만 더욱 중요한 이유가 있다.&lt;/p&gt;
&lt;h1 id=&#34;다른-사람과의-협업을-고려하자&#34;&gt;다른 사람과의 협업을 고려하자.&lt;/h1&gt;
&lt;p&gt;개발은 혼자 할 수 도 있지만 여러 명과 같이 할 수도 있다.&lt;/p&gt;
&lt;p&gt;클래스로 짜놓으면, 누가 봐도 &amp;lsquo;아 이 부분은 자동차를 구현하려고 한 거구나&amp;rsquo;를 알 수 있다.(주석 없이도!) if-else 문을 100번 반복한다고 했을 때, 같이 협업하는 사람이 보면 과연 이 코드를 제대로 이해할까? 필자였다면, 머릿속에 물음표만을 띄웠을 것이다.&lt;/p&gt;
&lt;p&gt;그런 면에서 봤을 때, 객체 지향 프로그래밍이 많이 쓰이는 이유를 알 수 있을 것이다.&lt;/p&gt;
&lt;h1 id=&#34;맹신은-금물&#34;&gt;맹신은 금물.&lt;/h1&gt;
&lt;p&gt;어느 패러다임이 항상 정답은 경우는 없다. 객체 지향이 무조건 옳지도 않고, 상황에 따라 절차 지향적으로 개발하는 것이 더 좋을 때도 있다.&lt;/p&gt;
&lt;p&gt;항상 요구사항에 맞게 개발하는 것이 중요하다. 무조건적인 적용은 오히려 협업을 방해할 수도 있다는 것을 명심하자.&lt;/p&gt;
&lt;h1 id=&#34;마무리하며&#34;&gt;마무리하며&lt;/h1&gt;
&lt;p&gt;오늘은 객체 지향에 대해 설명해 보았다. 필자도 객체지향에 대해 설명하면서, 알고 있다고 생각했지만 머릿속에 막연히 있는 개념을 글로 풀어내는 것이 참 어렵다고 느낀다. 이 개념을 처음 접하는 분들도 이해하지 못한 부분이 있을 것이라고 생각한다. 그런 부분이 있다면 댓글로 물어봐주시길 바란다.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
