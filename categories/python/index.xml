<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on fhdufhdu</title><link>https://fhdufhdu.github.io/categories/python/</link><description>Recent content in python on fhdufhdu</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><lastBuildDate>Thu, 04 Jan 2024 23:10:00 +0900</lastBuildDate><atom:link href="https://fhdufhdu.github.io/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>[Python] [실무] 커스텀 Router 객체를 만들어 보았다.</title><link>https://fhdufhdu.github.io/post/6/</link><pubDate>Thu, 04 Jan 2024 23:10:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/6/</guid><description>&lt;img src="https://fhdufhdu.github.io/summary-img/python.png" alt="Featured image of post [Python] [실무] 커스텀 Router 객체를 만들어 보았다." />&lt;h1 id="문제">문제&lt;/h1>
&lt;p>​
회사에서 필자가 개발한, 멀티 챗봇 시스템에 VOC가 들어오게 되었다. 해당 내용은 &amp;ldquo;가끔 너무 챗봇이 느려요&amp;quot;였다.
​
챗봇 모델 쪽에서 응답이 늦는 경우는 자주 있었기에, 이번에도 그렇겠거니 하고 확인을 해보았다.
​
그런데, 로그에 찍힌 시간을 보니, 모델은 빠른 시간 내에 응답을 해주는 것을 확인했다. 거기서 문제가 있다는 것을 깨닫고, 문제점을 찾아가기 시작했다.
​
문제는 importlib이라는 python 기본 라이브러리가 문제였다. 해당 라이브러리를 사용할 때 간헐적으로 최대 1.8초나 지연되는 현상이 발생했다.
​&lt;/p>
&lt;h2 id="기존-라우팅-방식">기존 라우팅 방식&lt;/h2>
&lt;p>​
우선 간략하게 현재 개발 환경을 말하자면 아래와 같다.
​&lt;/p>
&lt;ul>
&lt;li>AWS Lambda(람다)&lt;/li>
&lt;li>AWS Api Gateway&lt;/li>
&lt;li>PostgreSQL&lt;/li>
&lt;li>Python&lt;/li>
&lt;li>웹 프레임워크 사용하지 않음
​&lt;/li>
&lt;/ul>
&lt;p>챗봇 서버는 웹 프레임워크를 사용하지 않았기에, 챗봇별로 로직을 실행할 때 &lt;code>importlib&lt;/code>이라는 라이브러리를 이용해서 라우팅을 실시했다. &lt;code>importlib&lt;/code>은 동적으로 import를 할 수 있게 도와주는 라이브러리이다.
​
예를 들어 body에 &lt;code>chatbotId&lt;/code>가 &lt;code>Foo&lt;/code>이면 &lt;code>FooFacade&lt;/code> 클래스를 import 해서 쓰거나, &lt;code>Bar&lt;/code>이면 &lt;code>BarFacade&lt;/code> 클래스를 import해서 쓰거나 하는 식으로 진행했다.
​
그런데 &lt;code>importlib&lt;/code>이 느리다니&amp;hellip; 이해가 되지 않았다. &lt;code>importlib&lt;/code>은 결국 &lt;code>__import__&lt;/code> 함수의 래퍼이다. &lt;code>__import__&lt;/code>함수는 import 구문을 만나면 실행되는 기본적인 함수이다. 이게 느리다면, 파이썬을 사용해도 되는 것일까?
​&lt;/p>
&lt;h2 id="import의-작동-방식에-대해서-알아보자">Import의 작동 방식에 대해서 알아보자&lt;/h2>
&lt;p>​
해당 정보는 &lt;a class="link" href="https://medium.com/@likegondry/python-til-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%B4-import%EB%A1%9C-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%84-%EB%B6%88%EB%9F%AC%EC%98%A4%EB%8A%94-%EB%B0%A9%EB%B2%95-76e268e7613b" target="_blank" rel="noopener"
>김지연 님의 블로그&lt;/a>를 참고해서 작성했다.
​&lt;/p>
&lt;h2 id="1-sysmodule에-모듈이-존재하는지-찾아보기">1. sys.module에 모듈이 존재하는지 찾아보기&lt;/h2>
&lt;p>​
sys.module에는 이때까지 사용했던 module들이 딕셔너리 형태로 저장되어 있다. import시 해당 모듈이 이전에 import 된 것이라면 빠르게 가져올 수 있다.
​&lt;/p>
&lt;h2 id="2-syspath에-저장된-파일-목록들-하나하나-찾아보기">2. sys.path에 저장된 파일 목록들 하나하나 찾아보기&lt;/h2>
&lt;p>​
이 작업이 좀 오래 걸린다. 파일 리스트을 하나하나 탐색하면서 모듈을 가져오기 때문에 시간이 오래걸린다. 아마 필자의 생각으로는 File I/O 작업이라서 오래 걸리는 것 같다.
​&lt;/p>
&lt;h2 id="그럼-동적으로-import-하는-것은">그럼 동적으로 import 하는 것은&amp;hellip;?&lt;/h2>
&lt;p>​
만약 &lt;code>FooFacade&lt;/code> 클래스를 &lt;strong>처음&lt;/strong> 동적으로 import 한다면, 생각보다 시간이 오래 걸릴 수 있겠다는 생각이 들었다. 실제로도 처음 실행할 때와, 조금 유휴시간이 지난 후 실행하면 &lt;code>importlib&lt;/code> 동작 시간이 오래 걸리는 것을 확인할 수 있었다.
​
심지어 AWS 람다를 이용하고 있어서, 일정 유휴시간이 지나면 컨테이너가 내려가버린다. 그렇다면 새롭게 컨테이너가 생성될 때마다, &lt;code>importlib&lt;/code>에서 시간을 많이 잡아먹었다.
​&lt;/p>
&lt;h1 id="해결방법">해결방법&lt;/h1>
&lt;p>​
이제 문제점을 찾았으니 해결을 해보자.
​
결국 라우팅의 문제였으니, 이 라우팅을 다른 방식으로 하면 되지 않을까?
​
그래서 유명한 파이썬 웹 프레임워크인 FastAPI의 &lt;a class="link" href="https://github.com/tiangolo/fastapi" target="_blank" rel="noopener"
>깃허브 소스&lt;/a>를 뜯어보았다.
​
FastAPI는 어떻게 라우팅을 사용하고 있을까?
​&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> fastapi &lt;span style="color:#f92672">import&lt;/span> APIRouter, FastAPI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">​&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app &lt;span style="color:#f92672">=&lt;/span> FastAPI()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>internal_router &lt;span style="color:#f92672">=&lt;/span> APIRouter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>users_router &lt;span style="color:#f92672">=&lt;/span> APIRouter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">​&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@users_router.get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/users/&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">read_users&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> [{&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Rick&amp;#34;&lt;/span>}, {&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Morty&amp;#34;&lt;/span>}]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">​&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>internal_router&lt;span style="color:#f92672">.&lt;/span>include_router(users_router)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app&lt;span style="color:#f92672">.&lt;/span>include_router(internal_router)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​
이런 식으로 &lt;code>APIRouter&lt;/code> 객체를 하나 생성하고, APIRouter 객체의 &lt;code>get&lt;/code>(&lt;code>post&lt;/code>, &lt;code>put&lt;/code>, &amp;hellip;) 함수를 라우팅 하고자 하는 함수에 데코레이터로 붙여준다. 그리고 &lt;code>app&lt;/code> 객체에 해당 라우터를 전달한다.
​
이후 http 요청이 들어오면 &lt;code>app&lt;/code> 객체로 전달되고, &lt;code>app&lt;/code> 객체는 라우팅 정보를 확인해서 해당 함수를 실행한다.
​
자 어떻게 이것이 가능할까.
​
필자의 생각은 아래와 같았다.
​&lt;/p>
&lt;ol>
&lt;li>&lt;code>APIRouter&lt;/code> 객체는 멤버 함수로 데코레이터로 사용가능한 함수를 가지고 있다.(ex. &lt;code>get&lt;/code>, &lt;code>post&lt;/code>, &lt;code>put&lt;/code>, &lt;code>patch&lt;/code>, &lt;code>delete&lt;/code>)&lt;/li>
&lt;li>데코레이터 함수는 자기가 붙은 함수를 객체 형태로 사용할 수 있다.&lt;br>
(ex. &lt;code>user_router&lt;/code>의 get 함수는 &lt;code>read_users&lt;/code> 함수를 객체형태로 사용가능)&lt;/li>
&lt;li>그렇다면 get을 호출하면, &lt;code>read_users&lt;/code> 같은 함수를 &lt;code>users_router&lt;/code>에 딕셔너리 형태로 저장하면 되겠네?&lt;br>
(ex. &lt;code>{&amp;quot;users&amp;quot;: read_user}&lt;/code> 와 같은 형태로)&lt;/li>
&lt;li>맞는 것 같은데&amp;hellip; 한번 확인해 볼까?
​
&lt;code>APIRouter&lt;/code>의 &lt;code>get&lt;/code> 함수를 보면 &lt;code>self.api_route(...)&lt;/code>를 호출하고 해당 결괏값을 바로 반환한다.
​
그렇다면 &lt;code>api_route&lt;/code> 함수를 보자.
​&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 너무 길어서 간략하게 축소한 버전이다.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">api_route&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path: str,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">**&lt;/span>kwargs,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Callable[[DecoratedCallable], DecoratedCallable]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">decorator&lt;/span>(func: DecoratedCallable) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> DecoratedCallable:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>add_api_route(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">**&lt;/span>kwargs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> func
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">​&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> decorator
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​
해당 함수를 보게 되면, &lt;code>user_router.get&lt;/code>이 &lt;code>read_users&lt;/code>에 데코레이터로 붙게 되는 순간 &lt;code>func&lt;/code> 파라미터에 &lt;code>read_users가&lt;/code> 들어오게 된다. 이후 &lt;code>self.add_api_route&lt;/code>를 호출하는데, 이때 아래와 같은 코드가 실행된다.
​&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">add_api_route&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path: str,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endpoint: Callable[&lt;span style="color:#f92672">...&lt;/span>, Any],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">**&lt;/span>kwargs,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 생략
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> route &lt;span style="color:#f92672">=&lt;/span> route_class(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>prefix &lt;span style="color:#f92672">+&lt;/span> path,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endpoint&lt;span style="color:#f92672">=&lt;/span>endpoint,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> 생략
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>routes&lt;span style="color:#f92672">.&lt;/span>append(route)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​
path는 &amp;ldquo;/user/&amp;rdquo;, endpoint는 &lt;code>read_users&lt;/code> 함수이다. 이 두 가지를 통해 &lt;code>route&lt;/code> 객체를 하나 만들고 이를 &lt;code>user_routes의&lt;/code> &lt;code>routes&lt;/code> 리스트에 추가한다.
​
필자가 생각한 3번 과정은 아니고, 리스트 탐색으로 라우팅을 하는 것이지만, 어찌 됐든 비슷하다고 생각했다.
​
그리고 path param을 생각하면 딕셔너리의 key, value 탐색보다 리스트 탐색이 더 낫다고 생각이 든다.(path param이 들어가면 어쨌든 n만큼 순회해야 하니까!)&lt;/p>
&lt;p>​
필자의 생각이 어느 정도 맞다는 걸 인지했으니 신나게 Router 객체를 제작해서 만들었다.
(아쉽게도 회사의 코드는 공개할 수 없으므로 비슷하게도 공개할 수 없다..)
​&lt;/p>
&lt;h1 id="결과">결과&lt;/h1>
&lt;p>​
무려 라우팅시 1.8초나 걸리던 것이 0.001초 미만에 해결되는 모습을 보였다. 해당 코드를 만들고 동료 개발자와 코드리뷰 때 &amp;ldquo;어떻게 이런 생각을 했냐&amp;quot;라고 하셔서 되게 기분이 좋았다.&lt;/p></description></item><item><title>[Python] 추상 클래스 만들기</title><link>https://fhdufhdu.github.io/post/2/</link><pubDate>Wed, 20 Dec 2023 12:16:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/2/</guid><description>&lt;img src="https://fhdufhdu.github.io/summary-img/python.png" alt="Featured image of post [Python] 추상 클래스 만들기" />&lt;h1 id="추상-클래스-만들기">추상 클래스 만들기&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> abc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BaseClass&lt;/span>(metaclass&lt;span style="color:#f92672">=&lt;/span>abc&lt;span style="color:#f92672">.&lt;/span>ABCMeta):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@abc.abstractmethod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 아래처럼 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BaseClass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __metaclass__ &lt;span style="color:#f92672">=&lt;/span> abc&lt;span style="color:#f92672">.&lt;/span>ABCMeta
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@abc.abstractmethod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ChildClass&lt;/span>(BaseClass):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;hello world!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">=&lt;/span> ChildClass()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위와 같이 &lt;code>metaclass&lt;/code>로 해당 클래스가 추상 클래스라는 것을 명시한다.&lt;/p>
&lt;p>이후 추상클래스로 쓰고 싶은 메서드에 &lt;code>abstractmethod&lt;/code> 데코레이터를 달면 된다.&lt;/p>
&lt;p>만약 상속받는 클래스에서 추상클래스를 구현하지 않으면 아래와 같이 에러가 뜬다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Traceback &lt;span style="color:#f92672">(&lt;/span>most recent call last&lt;span style="color:#f92672">)&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &lt;span style="color:#e6db74">&amp;#34;/var/task/main.py&amp;#34;&lt;/span>, line 12, in &amp;lt;module&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> ChildClass&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TypeError: Can&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>t instantiate abstract class ChildClass with abstract method run
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>