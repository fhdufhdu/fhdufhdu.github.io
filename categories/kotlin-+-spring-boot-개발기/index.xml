<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kotlin + Spring Boot 개발기 on fhdufhdu</title><link>https://fhdufhdu.github.io/categories/kotlin-+-spring-boot-%EA%B0%9C%EB%B0%9C%EA%B8%B0/</link><description>Recent content in Kotlin + Spring Boot 개발기 on fhdufhdu</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><lastBuildDate>Sat, 17 Feb 2024 21:00:00 +0900</lastBuildDate><atom:link href="https://fhdufhdu.github.io/categories/kotlin-+-spring-boot-%EA%B0%9C%EB%B0%9C%EA%B8%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>[CS] 왜 음수를 표현할 때 2의 보수를 사용할까?</title><link>https://fhdufhdu.github.io/post/16/</link><pubDate>Sat, 17 Feb 2024 21:00:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/16/</guid><description>&lt;h1 id="시작하며">시작하며&lt;/h1>
&lt;p>최근에 kotlin으로 Spring boot 프로젝트를 제작하고 있던 중에, SHA-512를 사용해야 했었다.
방법을 찾아보니, 굉장히 특이한 코드가 보였다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Integer&lt;/span>.toString((digest[i] and &lt;span style="color:#ae81ff">0xff&lt;/span>.toByte()) + &lt;span style="color:#ae81ff">0x100&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>).substring(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>해당 코드는 SHA-512를 거쳐서 나온 byte를 string으로 변경하는 코드인데, 왜 이렇게 쓰는 지 궁금해졌다.&lt;/p>
&lt;p>그래서 파고파고 공부하다보니, 어느새 2의 보수까지 오게 되었다. 2의 보수를 다시 한번 공부하다보니, 음수를 표현할 때 2의 보수를 왜 사용했는 지에 대해 알 것 같았다. 그래서 해당 내용을 정리하고자 한다.&lt;/p>
&lt;p>&lt;em>해당 내용은 필자의 주관적인 견해가 많이 포함되어 있습니다.&lt;/em>&lt;/p>
&lt;h1 id="보수란">보수란?&lt;/h1>
&lt;blockquote>
&lt;p>보수(補數)는 보충을 해주는 수를 의미한다. 이를테면 1에 대한 10의 보수는 9, 4에 대한 15의 보수는 11의 개념이다. 1에 대한 2의 보수는 1이다.&lt;br>
&lt;strong>출처&lt;/strong> - &lt;a class="link" href="https://ko.wikipedia.org/wiki/%EB%B3%B4%EC%88%98_%28%EC%88%98%ED%95%99%29" target="_blank" rel="noopener"
>위키피디아&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>조금 더 보충 설명하자면, 보수는 각 자리의 수가 특정 수가 되게끔 보충해주는 수이다. 1에 대한 10의 보수는 9이고, 11에 대한 10의 보수는 89이다.&lt;/p>
&lt;h1 id="2의-보수란">2의 보수란?&lt;/h1>
&lt;p>이진법에서 2의 보수를 계산해보자. $1_2$에 2의보수를 하면 $1_2$이고, $10_2$에 2의 보수를 하면 $10_2$이다. $11_2$에 2의 보수를 하면 $1_2$일 것이다.&lt;/p>
&lt;p>이진법에서 1의 보수는 바로 이진수를 토글한 것이다. 여기에 +1을하면 2의 보수를 바로 구할 수 있다.&lt;/p>
&lt;p>예시) $0011\ 0110_2 =&amp;gt; 1100\ 1001_2 =&amp;gt; 1100\ 1010_2$&lt;/p>
&lt;blockquote>
&lt;p>토글이란? &lt;br> 이진수에서 0은 1로, 1은 0으로 변경하는 연산을 말한다. 각 비트에 not 연산을 한 것과 같다. 그래서 이진법에서 1의 보수는 매우 간단한 연산이다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>n진법일 때 n의 보수 쉽게 구하기&lt;br>n-1의 보수를 구해서 +1을 하면 n의 보수를 바로 구할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;h1 id="이진수-토글의-특징">이진수 토글의 특징&lt;/h1>
&lt;p>이진수를 토글한 후의 값은 특정 수식을 따른다. 어려운 수식은 아니고 정말 간단한 수식이다. 사실 보수의 특징을 생각한다면 쉽게 생각할 수 있다.&lt;/p>
&lt;blockquote>
&lt;p>$\{비트\ 수에\ 맞는\ 최대값\}-\{기존값\} = \{토글된\ 값\}$&lt;/p>
&lt;/blockquote>
&lt;p>$0011\ 0110_2$을 토글하면 $1100\ 1001_2$이 된다.
십진수로 표현하면 54 -&amp;gt; 201가 된 것이다. 이를 다시 수식에 한번 대입해보자.&lt;/p>
&lt;ol>
&lt;li>1 byte에서 최대값 255&lt;/li>
&lt;li>$0011\ 0110_2$은 십진수로 54&lt;/li>
&lt;li>255 - 54 = 201&lt;/li>
&lt;li>토글된 값은 $1100\ 1001_2$이고 이 값은 십진수로 201임&lt;/li>
&lt;li>3번과 4번의 값이 같으므로 수식이 성립함&lt;/li>
&lt;/ol>
&lt;h1 id="1byte로-표현되는-음수의-범위">1byte로 표현되는 음수의 범위&lt;/h1>
&lt;p>1byte로 표현되는 양수의 범위는 0~255($2^8$ = 256개 만큼)인 것은 다들 잘 알고 있을 것이다. 그렇다면 음수는 어떻게 표현할까?&lt;/p>
&lt;ul>
&lt;li>양수 범위 : $0000\ 0000_2$ ~ $0111\ 1111_2$ ($2^7$ = 128개)&lt;/li>
&lt;li>음수 범위 : $1000\ 0000_2$ ~ $1111\ 1111_2$ ($2^7$ = 128개)&lt;/li>
&lt;/ul>
&lt;p>양수와 음수를 가르는 결정적인 차이는 최상위 비트이다. 최상위 비트가 0이면 양수, 1이면 음수로 표현하는 것이다.&lt;/p>
&lt;p>그렇다면, 왜 최상위 비트로 결정하는 것일까? &lt;strong>그 이유는 표현 가능한 수의 개수를 정확히 2등분 하기 때문이다.&lt;/strong>&lt;/p>
&lt;p>양수와 음수를 범위를 맞춤으로써 계산하기 쉽게 하기 위함이다.&lt;/p>
&lt;h1 id="최상위-비트가-1인-이진수는-어떻게-음수로-사용하는가">최상위 비트가 1인 이진수는 어떻게 음수로 사용하는가?&lt;/h1>
&lt;p>$1000\ 0000_2$은 128인데, 이 숫자를 대체 어떻게 음수로 사용할 수 있을까? 여기서 이진수 토글이 등장한다.&lt;/p>
&lt;p>앞서 이진수 토글은 $\{비트\ 수에\ 맞는\ 최대값\}-\{기존값\} = \{토글된\ 값\}$ 가 성립하는 특징을 가진다고 했다.&lt;/p>
&lt;p>그렇다면 최상위 비트가 1인 친구들을 토글해보자.&lt;/p>
&lt;ul>
&lt;li>128 -&amp;gt; 127&lt;/li>
&lt;li>129 -&amp;gt; 126&lt;/li>
&lt;li>130 -&amp;gt; 125&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>253 -&amp;gt; 2&lt;/li>
&lt;li>254 -&amp;gt; 1&lt;/li>
&lt;li>255 -&amp;gt; 0&lt;/li>
&lt;/ul>
&lt;p>어떤가? 기존 값이 증가할 수록 토글된 값은 감소하는 것을 볼 수 있다.
여기에 -를 붙인다면? 음수로 사용해도 되지 않겠는가?&lt;/p>
&lt;h2 id="이진수-토글을-음수로-사용할-경우-문제">이진수 토글을 음수로 사용할 경우 문제&lt;/h2>
&lt;p>앞서 진행한 과정을 보면 완벽해보인다. 하지만, 문제가 딱 한가지 있다. 그것은 쓸모없는 값이 하나 존재한다는 것이다.&lt;/p>
&lt;p>최상위 비트가 1인 수를 이진수 토글을 통해 음수로 표현하게 되면 $-127&amp;hellip;-0,0&amp;hellip;127$와 같은 범위를 가지게 된다.&lt;/p>
&lt;p>어라, -0이라는 값이 등장했다. 255를 이진수 토글하면 0이고 여기에 -를 붙이기로 했으니 -0이 나오기는 한다. 그런데 이는 0과 중복되는 의미를 가진다. 즉, 쓸모없는 데이터가 존재한다는 것이다.&lt;/p>
&lt;h2 id="1을-해서-해결해보자">+1을 해서 해결해보자&lt;/h2>
&lt;p>응당 개발자라면 이런 값은 눈 뜨고도 쳐다볼 수 없어야한다.(필자는 좀 그렇다&amp;hellip;) 그렇다면 이진수 토글 이후 +1을 하면 해결되지 않겠는가?&lt;/p>
&lt;ul>
&lt;li>128 -&amp;gt; 128&lt;/li>
&lt;li>129 -&amp;gt; 127&lt;/li>
&lt;li>130 -&amp;gt; 126&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>253 -&amp;gt; 3&lt;/li>
&lt;li>254 -&amp;gt; 2&lt;/li>
&lt;li>255 -&amp;gt; 1&lt;/li>
&lt;/ul>
&lt;p>드디어 $-128&amp;hellip;-1,0&amp;hellip;127$ 와 같은 우리가 흔히 보는 범위가
완성되었다.&lt;/p></description></item></channel></rss>