<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on fhdufhdu</title><link>https://fhdufhdu.github.io/categories/javascript/</link><description>Recent content in javascript on fhdufhdu</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><lastBuildDate>Wed, 03 Jan 2024 23:34:00 +0900</lastBuildDate><atom:link href="https://fhdufhdu.github.io/categories/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>[JS] 이벤트 루프와 비동기 함수</title><link>https://fhdufhdu.github.io/post/5/</link><pubDate>Wed, 03 Jan 2024 23:34:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/5/</guid><description>&lt;img src="https://fhdufhdu.github.io/summary-img/javascript.png" alt="Featured image of post [JS] 이벤트 루프와 비동기 함수" />&lt;p>오늘은 JS의 비동기에 대해 설명해보고자 한다. JS에 대해 잘 모르고 비동기에 대한 개념이 희박하던 때, 단순히 콜백함수가 비동기 함수인 줄 알았다. 하지만 단순히 콜백함수를 만든다고 해서 비동기적으로 작동하는 것은 아니다. 특정 조건의 함수만 비동기 함수가 될 수 있다.&lt;/p>
&lt;p>동기와 비동기 작업에 대해 알아보고 싶다면 해당 &lt;a class="link" href="https://fhdufhdu.github.io/page/4" >게시글&lt;/a>을 참고하자.&lt;/p>
&lt;p>조금 더 자세히 알아보자.&lt;/p>
&lt;h1 id="콜백-함수는-동기이다">콜백 함수는 동기이다.&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">num&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#a6e22e">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">count&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, (&lt;span style="color:#a6e22e">num&lt;/span>) =&amp;gt;{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;============================&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">count&lt;/span>(&lt;span style="color:#ae81ff">1000&lt;/span>, (&lt;span style="color:#a6e22e">num&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">1000&lt;/span>, &lt;span style="color:#a6e22e">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>count 함수는 파라미터 num에 10번 반복문을 돌면서 1을 더하는 함수이다. 그리고 for가 끝나면 콜백을 실행한다.&lt;/p>
&lt;p>해당 코드를 실행하면 아래와 같은 결과가 나온다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>============================
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1001
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1002
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1003
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1004
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1005
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1006
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1007
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1008
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1009
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1000 1010
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>완벽하게 동기로 실행되는 것을 볼 수 있다. 그러므로 콜백함수를 만든다고 해서 비동기로 작동하지 않는다.&lt;/p>
&lt;h1 id="javascript-런타임">javascript 런타임&lt;/h1>
&lt;p>js에서 비동기를 이해하기 위해서는 &lt;code>javacript 런타임&lt;/code> 에 대해 이해할 필요가 있다.&lt;/p>
&lt;p>런타임은 어떠한 코드가 실제로 구동할 수 있는 환경을 의미힌다. 그러므로 당연하게도 &lt;code>javascript 런타임&lt;/code>은 js 코드를 실제로 구동할 수 있는 환경이다.&lt;/p>
&lt;p>&lt;code>javascript 런타임&lt;/code>도 종류가 있는데, 크게 분리하면 &lt;code>웹 브라우저&lt;/code> 와 &lt;code>node.js&lt;/code>가 있다. 웹 브라우저는 흔히 사용하는 크롬, 사파리, 파이어폭스 등이 있다.&lt;/p>
&lt;p>앞서 런타임은 구동 환경을 의미한다고 했다. &lt;code>javascript 런타임&lt;/code>에는 어떤 종류의 환경이 존재할까?&lt;/p>
&lt;ul>
&lt;li>&lt;code>javacript 엔진&lt;/code>
&lt;ul>
&lt;li>&lt;code>이벤트 루프&lt;/code> 포함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Web APIs&lt;/code>(node.js에서는 &lt;code>libuv&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>이 두가지가 존재한다.&lt;/p>
&lt;h2 id="javascript-엔진">javascript 엔진&lt;/h2>
&lt;p>그렇다면 &lt;code>javascript 엔진&lt;/code>이란 무엇일까? js 코드를 실제로 실행하는 영역이다. 개발자가 작성한 모든 js 코드는 &lt;code>javascript 엔진&lt;/code>에서 파싱되고 실행된다. 이 &lt;code>javascript 엔진&lt;/code>은 &lt;strong>싱글 스레드&lt;/strong>에서 작동한다.&lt;/p>
&lt;p>여기에는 흔히 알려져 있는 &lt;code>이벤트 루프&lt;/code>도 포함되어 있다. &lt;code>이벤트 루프&lt;/code>에 대해서는 뒤에서 자세하게 설명하도록 하겠다. 우선 이 &lt;code>이벤트 루프&lt;/code>가 &lt;code>javascript 엔진&lt;/code>에서 작동한다는 사실만 기억하자.&lt;/p>
&lt;h3 id="javascript-엔진의-구성-요소">javascript 엔진의 구성 요소&lt;/h3>
&lt;ul>
&lt;li>콜 스택 (call stack)
&lt;ul>
&lt;li>
&lt;p>실행되어야할 함수들을 저장하는 곳&lt;/p>
&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">num&lt;/span>) =&amp;gt; { &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">num&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://fhdufhdu.github.io/post/5/image.png"
width="1280"
height="678"
loading="lazy"
alt="JS 콜스택"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>test(1)&lt;/code>이 이 콜스택에 삽입 후 실행&lt;/li>
&lt;li>&lt;code>test(1)&lt;/code>에 있는 &lt;code>console.log(1)&lt;/code>을 콜스택에 삽입 후 실행&lt;/li>
&lt;li>1이 출력 후 &lt;code>console.log(1)&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>&lt;code>test(1)&lt;/code> 콜스택에서 제거&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>힙 (heap)
&lt;ul>
&lt;li>데이터가 동적으로 저장되는 공간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이벤트 루프(event loop)
&lt;ul>
&lt;li>비동기 작업이 끝난 후 결과값을 처리할 &lt;strong>콜백 함수를 저장해두는 곳&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="web-apis">Web APIs&lt;/h2>
&lt;p>&lt;code>웹 브라우저&lt;/code>에서 비동기적인 이벤트를 처리하기 위해 제공하는 API들이다. &lt;code>웹 브라우저&lt;/code>에서 제공하는 것이기 때문에, 해당 api는 &lt;code>javascript 엔진&lt;/code>에서 실행되지 않는다. 이 api들은 &lt;code>javascript 엔진&lt;/code>과 실제로 다른 프로세스에서 실행되며, js에서 호출할 수 있도록 &lt;code>javascript 엔진&lt;/code>에서는 인터페이스만 제공한다.&lt;/p>
&lt;h3 id="여기서-잠깐-인터페이스만-제공한다는-것의-의미란">여기서 잠깐! 인터페이스만 제공한다는 것의 의미란?&lt;/h3>
&lt;p>API는 Application Programming Interface의 약자이다. 이는 &lt;strong>두 개의 서로 다른 프로세스(혹은 프로그램)간에 통신을 위한 일종의 약속&lt;/strong>이다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>A&lt;/code>와 &lt;code>B&lt;/code>라는 두 개의 프로세스가 있고, &lt;code>B&lt;/code>에는 &lt;code>getData&lt;/code>라는 기능이 있다. &lt;code>A&lt;/code>에서 &lt;code>B&lt;/code>의 &lt;code>getData&lt;/code>라는 기능을 사용하기 위해서는 &lt;code>getData&lt;/code>의 실행에 필요한 데이터를 전달해 주어야 한다.
이때 &lt;strong>&amp;quot;&lt;code>B&lt;/code>는 특정 형태의 프로토콜과 특정 형태의 구조로 데이터를 전달해주면, &lt;code>getData&lt;/code>라는 기능을 실행하고, 결과를 특정한 형태로 응답해주겠다&amp;quot;&lt;/strong> 라고 약속하는 것이 바로 API라고 할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>Web APIs&lt;/code>도 똑같다. 실제 &lt;code>Web APIs&lt;/code>는 js 코드로 실행하면, &lt;code>javascript 엔진&lt;/code>이 해당 요청을 다른 프로세스(=웹 브라우저)에게 요청하고, 응답을 받으면 그것을 js에서 사용할 수 있도록 결과값을 반환해주는 역할을 한다.&lt;/p>
&lt;p>즉, &lt;code>javascript 엔진&lt;/code>과 &lt;code>웹 브라우저&lt;/code> 간의 통신 약속이 바로 &lt;code>Web APIs&lt;/code>이다.&lt;/p>
&lt;p>해당 게시글을 처음 시작할 때, 특정 조건의 함수만 비동기가 될 수 있다고 했다. 그 특정 조건의 함수란 바로, &lt;code>Web APIs&lt;/code>에 등록된 함수이다.&lt;/p>
&lt;p>&lt;a class="link" href="https://developer.mozilla.org/ko/docs/Web/API" target="_blank" rel="noopener"
>Web APIs 함수 목록-mdn web docs&lt;/a>&lt;/p>
&lt;h1 id="이벤트-루프">이벤트 루프&lt;/h1>
&lt;p>이벤트 루프를 이해하기 위해서는 비동기에 대한 이해가 필요하다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;!-- raw HTML omitted -->비동기란?&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->
파일 저장, 네트워크 요청 등 처리에 시간이 걸리는 I/O 작업이 진행 중에 다른 코드를 실행하는 것을 의미한다.&lt;!-- raw HTML omitted -->
시간이 걸리는 작업 중에는 프로그램은 놀고 있는 것이기 때문에, 이 시간을 최대한 활용하기 위해 나온 개념이다.&lt;/p>
&lt;/blockquote>
&lt;p>js는 싱글 스레드이기 때문에, 비동기 코드를 실행할 수 없다. 그래서 앞서 설명한 &lt;code>Web APIs&lt;/code>를 통해 브라우저에게 비동기 작업을 요청한다. 그렇다면, 비동기 작업이 종료되었을때, 응답을 받을 것이다. 그 응답은 어떻게 처리해야 할까?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">setTimeout&lt;/span>(()=&amp;gt;{&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)}, &lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">결과
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위와 같은 코드를 보자. 해당 코드는 실행하면 2가 출력되고 1초 후 1이 출력될 것이다. 조금 이상하지 않은가? 코드는 위에서 아래로 진행하면서 실행될 텐데, 1, 2가 출력되는 것이 아니라 2, 1로 반대로 출력된다. 마치 이것은 두 번째 줄이 먼저 실행되고, 첫 번째 줄이 실행된 것 처럼 보인다.&lt;/p>
&lt;p>이것이 앞서 설명한 응답 처리에 대한 질문의 답이라고 할 수 있다. 코드 실행을 순서대로 알아보자&lt;/p>
&lt;ul>
&lt;li>&lt;code>setTimeout&lt;/code> 콜스택에 삽입 후 실행&lt;/li>
&lt;li>1초 타이머를 &lt;code>Web API&lt;/code>를 통해 &lt;code>웹 브라우저&lt;/code>에게 요청, 이때 &lt;code>()=&amp;gt;{console.log(1)}&lt;/code>을 같이 &lt;code>웹 브라우저에게 전달&lt;/code>&lt;/li>
&lt;li>&lt;code>setTimeout&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>&lt;code>console.log(2)&lt;/code> 콜스택에 삽입 후 실행&lt;/li>
&lt;li>2 출력&lt;/li>
&lt;li>&lt;code>console.log(2)&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>1초가 지난 후 &lt;code>웹 브라우저&lt;/code>는 &lt;code>()=&amp;gt;{console.log(1)}&lt;/code>을 &lt;code>이벤트 루프&lt;/code> 큐에 삽입&lt;/li>
&lt;li>&lt;code>이벤트 루프&lt;/code>는 큐에 &lt;code>()=&amp;gt;{console.log(1)}&lt;/code>가 생겼으므로, 해당 함수를 콜스택에 삽입&lt;/li>
&lt;li>&lt;code>()=&amp;gt;{console.log(1)}&lt;/code> 실행&lt;/li>
&lt;li>&lt;code>console.log(1)&lt;/code> 콜스택에 삽입 후 실행&lt;/li>
&lt;li>1 출력&lt;/li>
&lt;li>&lt;code>console.log(1)&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>&lt;code>()=&amp;gt;{console.log(1)}&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>종료&lt;/li>
&lt;/ul>
&lt;p>이렇듯, 코드는 순차적으로 실행된 것이 맞고, 응답 처리의 방법은 비동기 작업이 종료된 이후 처리할 코드를 미리 넘겨주는 것이다. 이것이 바로 &lt;code>콜백 함수&lt;/code>이다. 위 예제에서 콜백 함수는 &lt;code>()=&amp;gt;{console.log(1)}&lt;/code>이다.&lt;/p>
&lt;p>그리고 이벤트 루프의 역할은 &lt;strong>비동기 처리가 완료된 이후 실행되어야 할 콜백 함수들의 저장소&lt;/strong>이다. 이 이벤트 루프는 콜백 함수를 저장하고, 일정 주기(틱)마다 콜백 함수 큐를 확인해서 콜백 함수가 존재하면 해당 함수를 콜 스택에 삽입한다.&lt;/p>
&lt;p>아래 GIF를 보면 &lt;code>콜 스택&lt;/code>, &lt;code>웹 브라우저&lt;/code>, &lt;code>이벤트 루프&lt;/code>간의 상호작용을 한눈에 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://fhdufhdu.github.io/post/5/event-loop.gif"
width="720"
height="405"
loading="lazy"
alt="JS 비동기 작업 GIF"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;h1 id="정리">정리&lt;/h1>
&lt;ul>
&lt;li>콜백을 사용한다고 모두 비동기가 되는 것이 아니다.&lt;/li>
&lt;li>&lt;code>javascript 런타임&lt;/code>은 js를 실행하는 구동 환경이다.
&lt;ul>
&lt;li>&lt;code>javascript 엔진&lt;/code>과 &lt;code>Web APIs&lt;/code>로 구성된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>javascript 엔진&lt;/code>은 js를 파싱하고 실행한다.
&lt;ul>
&lt;li>싱글 스레드로 작동한다.&lt;/li>
&lt;li>여기서는 비동기가 작동할 수 없다.&lt;/li>
&lt;li>&lt;code>콜 스택&lt;/code>, &lt;code>힙&lt;/code>, &lt;code>이벤트 루프&lt;/code>로 구성된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Web APIs&lt;/code>는 &lt;code>웹 브라우저&lt;/code>에서 비동기 이벤트를 처리하기 위해 제공되는 api이다.
&lt;ul>
&lt;li>&lt;code>javascript 엔진&lt;/code>은 비동기 요청을 &lt;code>Web APIs&lt;/code>를 통해 &lt;code>웹 브라우저&lt;/code>에게 전달한다.&lt;/li>
&lt;li>&lt;code>웹 브라우저&lt;/code>는 비동기 작업이 끝나면 콜백 함수를 &lt;code>이벤트 루프&lt;/code> 콜백 함수 큐에 삽입힌다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>콜백 함수&lt;/code>란 비동기 요청이 끝난 후 응답을 처리하는 함수이다.&lt;/li>
&lt;li>&lt;code>이벤트 루프&lt;/code>란 콜백 함수 저장소이다.
&lt;ul>
&lt;li>&lt;code>일정 주기(틱)&lt;/code>마다 콜백 함수 큐를 검사하고, 콜백 함수가 존재하면 콜 스택에 해당 함수를 삽입한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>[CS] 동기/비동기에 대해서 알아보자(sync/async)</title><link>https://fhdufhdu.github.io/post/4/</link><pubDate>Tue, 02 Jan 2024 22:15:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/4/</guid><description>&lt;p>오늘은 동기와 비동기에 대해서 설명하고자 한다.&lt;/p>
&lt;p>해당 개념은 설명만 들으면 쉽게 이해가 될 수도 있지만, 헷갈릴 여지도 많은 개념이라고 생각한다.&lt;/p>
&lt;p>특히 스레드 개념과 엮이기 시작하면 많이 헷갈리기 시작하는 개념이다.&lt;/p>
&lt;h1 id="동기sync">동기(Sync)&lt;/h1>
&lt;p>동기가 제일 간단하다. 흔히 우리가 쓰는 코드를 상상하면 된다.&lt;/p>
&lt;p>아래 JS 예제가 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 결과는 위에서부터 순차적으로 실행되어 아래와 같은 결과를 보일 것이다.&lt;/p>
&lt;p>&lt;img src="https://fhdufhdu.github.io/post/4/image.png"
width="210"
height="216"
loading="lazy"
alt="코드 결과"
class="gallery-image"
data-flex-grow="97"
data-flex-basis="233px"
>&lt;/p>
&lt;h1 id="비동기async">비동기(Async)&lt;/h1>
&lt;p>자 이제 비동기에 대해 이해해 보자. 단순하게 비동기는 동기의 반대말이다. 동기가 순차적으로 실행되는 것을 의미하니까 비동기는 순차적으로 실행되지 않는다고 생각하면 된다. 순차적으로 실행되지 않는다면, 코드의 실행순서를 파악하기 힘들 것이다. 이렇게 생각했을 때 비동기가 정말 필요한지에 대해 의문점이 생긴다.&lt;/p>
&lt;h2 id="비동기의-필요성">비동기의 필요성&lt;/h2>
&lt;p>비동기가 등장한 이유는 낭비되는 시간이 아까워서이다. 아래와 같은 코드를 보자&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 해당 코드는 psuedo 코드이다.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">reqBody&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;choding&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;is good&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">requests&lt;/span>.&lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://localhost:3000&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">reqBody&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 이후 필요한 로직 실행!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>단순하게 http 요청을 보내는 코드이다. 이 코드가 동기적으로 작동한다면 대락 100초 이후에 console.log(response.body)가 실행되고 이후 로직이 작동할 것이다. 근데 http 요청을 보내고, 받는 100초 동안 프로세스는 무엇을 하고 있을까?&lt;/p>
&lt;p>정답은 &lt;strong>&amp;ldquo;아무것도 안하고 있다.&amp;rdquo;&lt;/strong> 이다. 정말 아무것도 안 하고 http 응답을 받는 순간까지 기다리는 것만 진행할 것이다. 만약 이 100초라는 시간에 다른 작업을 하면 어떨까? 웬만하면 많은 작업들을 처리할 수 있을 것이다.&lt;/p>
&lt;p>이 남는 시간을 활용하기 위해 비동기라는 개념이 등장했다.&lt;/p>
&lt;p>&lt;img src="https://fhdufhdu.github.io/post/4/image-1.png"
width="1440"
height="554"
loading="lazy"
alt="비동기 작동 과정"
class="gallery-image"
data-flex-grow="259"
data-flex-basis="623px"
>&lt;/p>
&lt;p>위 그림처럼, 2번이 완료되지 않았음에도, 2번의 응답이 오기까지의 시간동안 다른 작업을 하는 것이 바로 비동기라고 할 수 있다.&lt;/p>
&lt;h2 id="콜백">콜백&lt;/h2>
&lt;p>앞서 비동기의 필요성을 말했다. 그렇다면 100초 동안 비는 시간에 다른 작업을 하고 나서, 응답을 받는 순간에는 어떻게 될까? 해당 값으로 처리하는 로직이 필요할 것이다. 그것이 바로 콜백(callback)이다.&lt;/p>
&lt;p>콜백의 주요 논지는 &lt;strong>&amp;ldquo;해야할 일을 뒤로 미루는 것&amp;rdquo;&lt;/strong> 이다.&lt;/p>
&lt;p>사실, 이름만 봐도 알 수 있다. callback은 회신하다/답신하다는 뜻이다.&lt;/p>
&lt;p>그러니까 &amp;ldquo;할일 다 하고(=해야 할 일 미루고), 네가 요청한 일 처리할 수 있을 때 처리하겠다&amp;quot;라는 것이다.&lt;/p>
&lt;p>아래 코드를 다시 보자.&lt;/p>
&lt;p>2번 과정이 100초가 걸리니까, 2번의 응답이 오는 100초 동안 다른 일을 JS가 한다고 하자. 이후 100초가 지난 후, 2번의 응답을 가지고 무언가 작업을 해야 할 것이다. 그런데, 어떻게 실행할 것인가? &lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 해당 코드는 psuedo 코드이다.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">reqBody&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;choding&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;is good&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">requests&lt;/span>.&lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://localhost:3000&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">reqBody&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 이후 필요한 로직 실행!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//100초 후...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//어라, 어떻게 응답을 처리하지?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//응답은 왔는데.... 처리할 코드를 어떻게 작성하지...?
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이때 콜백을 작성하면 응답을 처리할 수 있는 코드를 작성할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 해당 코드는 psuedo 코드이다.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">reqBody&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;choding&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;is good&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">requests&lt;/span>.&lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://localhost:3000&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">reqBody&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 4. 100초 후 이 함수 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">body&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 처럼 콜백 함수를 작성할 수 있을 것이다. 저 4번 콜백 함수는 http 응답이 오면 실행된다.&lt;/p>
&lt;p>4번의 콜백 함수는 앞서 말한 &lt;strong>&amp;ldquo;해야 할 일을 뒤로 미루는 것&amp;quot;과&lt;/strong> 같다.&lt;/p>
&lt;h1 id="마무리">마무리&lt;/h1>
&lt;p>간단하게 비동기와 콜백에 대해 알아보았다.&lt;/p>
&lt;p>이렇게 보면 비동기 자체는 크게 어렵지 않은 것 같다. 하지만 필자도 이 개념을 오해 없이 이해하기에 많은 시간이 들었다.&lt;/p>
&lt;p>여러분들도 오해없이 비동기를 이해할 수 있게 되었으면 좋겠다.&lt;/p></description></item></channel></rss>