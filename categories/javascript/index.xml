<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on fhdufhdu</title><link>https://fhdufhdu.github.io/categories/javascript/</link><description>Recent content in javascript on fhdufhdu</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><lastBuildDate>Mon, 18 Mar 2024 18:34:00 +0900</lastBuildDate><atom:link href="https://fhdufhdu.github.io/categories/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>[React] 가상 돔(Virtual DOM)이 왜 필요할까?</title><link>https://fhdufhdu.github.io/post/20/</link><pubDate>Mon, 18 Mar 2024 18:34:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/20/</guid><description>&lt;h2 id="들어가며">들어가며&lt;/h2>
&lt;p>나는 백엔드 개발자이지만 프론트, nlp, 보안 등등 여러 방면으로 공부하는 것을 좋아한다. 새로운 지식은 항상 재밌게 느껴지더라고&amp;hellip;&lt;/p>
&lt;p>그래서 오늘은 그냥 지극히 개인적인 궁금증으로 찾아본 가상 돔에 대해서 이야기해보고자 한다. 사실, 혼자 공부한 건 아니고 회사의 프론트엔드 개발자 분하고 같이 공부했다.&lt;/p>
&lt;h2 id="dom">DOM&lt;/h2>
&lt;p>DOM은 Document Object Model의 약자이다. 이는 HTML 요소들을 객체화해서 구조화해놓은 것을 의미한다. 이 DOM을 조작하기 위해서 JS가 탄생했다.&lt;/p>
&lt;p>하여튼, 이 DOM을 조작하게 되면, 다시 DOM이 구조화되고 새롭게 화면으로 그려진다. 이것을 리렌더링이라고 한다. 리렌더링이 반복되고 무수히 많이 일어난다면? 매우 느릴 것이다.&lt;/p>
&lt;p>한번 예를 들어보자.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">rootNode&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;root&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">forEach&lt;/span>((&lt;span style="color:#a6e22e">num&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">newNode&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;div&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">newNode&lt;/span>.&lt;span style="color:#a6e22e">innerHTML&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">num&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rootNode&lt;/span>.&lt;span style="color:#a6e22e">appendChild&lt;/span>(&lt;span style="color:#a6e22e">newNode&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이런 코드가 있다고 해보자.
이 코드는 forEach를 돌 때마다, 계속해서 리렌더링이 일어난다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">nums&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">rootNode&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;root&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">html&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">nums&lt;/span>.&lt;span style="color:#a6e22e">forEach&lt;/span>((&lt;span style="color:#a6e22e">num&lt;/span>)=&amp;gt;{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">newNode&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;div&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">newNode&lt;/span>.&lt;span style="color:#a6e22e">innerHTML&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">num&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">html&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">newNode&lt;/span>.&lt;span style="color:#a6e22e">outerHTML&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">rootNode&lt;/span>.&lt;span style="color:#a6e22e">innerHTML&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">html&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드는 어떨까? 단 한 번 업데이트하는 것이기 때문에 리렌더링도 단 한 번 일어날 것이다.&lt;/p>
&lt;p>이렇듯 한 번에 모아서 업데이트를 하면 렌더링 횟수를 줄일 수 있다.&lt;/p>
&lt;h2 id="가상-돔virtual-dom">가상 돔(Virtual DOM)&lt;/h2>
&lt;p>&lt;img src="https://fhdufhdu.github.io/post/20/image.png"
width="755"
height="304"
loading="lazy"
alt="출처 https://callmedevmomo.medium.com/virtual-dom-react-%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC-bfbfcecc4fbb"
class="gallery-image"
data-flex-grow="248"
data-flex-basis="596px"
>&lt;/p>
&lt;p>리액트는 이렇게 변경점을 한 번에 업데이트 하기 위해서, 가상 돔이라는 것을 만들어 냈다. 이 가상 돔은 실제 돔을 복사한 것이다. 그래서 아무리 이 가상 돔을 업데이트해도 실제로 업데이트가 일어나지는 않는다.&lt;/p>
&lt;p>가상 돔은 총 두 가지가 존재한다. 원본 가상 돔과, 변경 가상 돔이다. 실제로 상태 값이 업데이트된다면, 리액트는 변경 가상 돔을 건드려 값을 업데이트 한다. 이후 diffing을 통해서 원본 가상 돔과 변경 가상 돔을 비교해서 어느 부분이 업데이트 되었는지를 확인한다.&lt;/p>
&lt;p>이후 리액트는 위의 코드처럼 실제 돔에 한 번에 업데이트 할 수 있도록 코드를 작성하고, 실제 돔에 업데이트를 진행한다. 그렇다면 리렌더링을 최소화할 수 있다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>오늘은 궁금했던 가상 돔에 대해서 얘기해 보았다. 사실 프론트엔드 개발자가 아니라서 자세하게 작성하지는 않았지만, 왜 필요한지는 정리해야 할 것 같아서 포스팅하게 되었다. 언젠가 이런 구조를 내가 백엔드에서 써먹을 수도 있을 수도 있으니까! 개발한 코드와 구조는 돌고 돈다고 생각한다.&lt;/p>
&lt;div id="fhdufhdu-card">
&lt;/div>
&lt;script>
const resize = () => {
var iamges = []
var interval = setInterval(()=>{
images = document.querySelectorAll('.gallery')
if (images.length > 0){
images.forEach((image)=>{
const getEm = (width) => {
if (width > 1535) return 4
else if(width &lt; 0) return 0
return (4/767) * width - (3072/767)
}
const em = getEm(window.innerWidth)
image.style.padding = `0 ${em}em 0 ${em}em`
})
clearInterval(interval)
}
}, 100)
}
window.addEventListener("resize", resize)
resize()
&lt;/script></description></item><item><title>[JS] this 바인딩에 대해 알아보자</title><link>https://fhdufhdu.github.io/post/12/</link><pubDate>Wed, 17 Jan 2024 13:08:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/12/</guid><description>&lt;h2 id="this란">this란?&lt;/h2>
&lt;p>일반적으로 대부분의 언어에서 &lt;code>this&lt;/code> 키워드는 자기 자신의 인스턴스를 가리키는 용어이다.(python에서는 &lt;code>self&lt;/code> 키워드)&lt;/p>
&lt;p>하지만, javascript의 &lt;code>this&lt;/code> 키워드는 다른 언어와는 다른 방식으로 작동한다.&lt;/p>
&lt;p>* chrome 브라우저 환경에서 테스트한 결과입니다. node의 경우 &lt;code>window&lt;/code> 전역 객체 대신 &lt;code>global&lt;/code> 전역 객체를 사용하는데, &lt;code>global&lt;/code>이 제대로 반환되지 않아서 브라우저 환경에서 진행하였습니다.&lt;/p>
&lt;h3 id="java에서의-this">Java에서의 &lt;code>this&lt;/code>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> number;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> number){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Test t1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Test();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Test t2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Test();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t1.&lt;span style="color:#a6e22e">setNumber&lt;/span>(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t2.&lt;span style="color:#a6e22e">setNumber&lt;/span>(2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(t1.&lt;span style="color:#a6e22e">number&lt;/span>); &lt;span style="color:#75715e">// 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(t2.&lt;span style="color:#a6e22e">number&lt;/span>); &lt;span style="color:#75715e">// 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>당연하게도 Java에서의 &lt;code>this&lt;/code>는 Test 인스턴스를 가리킨다는 것을 알 수 있다. 그렇다면 js에서는 어떻게 작동할까?&lt;/p>
&lt;h2 id="javascript에서의-this">javascript에서의 &lt;code>this&lt;/code>&lt;/h2>
&lt;h3 id="this-바인딩-규칙">&lt;code>this&lt;/code> 바인딩 규칙&lt;/h3>
&lt;p>우선 설명 이전에, 바인딩 규칙부터 알아보자.&lt;/p>
&lt;ol>
&lt;li>일반 함수(function 키워드 사용)에서 사용된 &lt;code>this&lt;/code>는 해당 함수를 호출하는 객체를 가리킨다.&lt;/li>
&lt;li>화살표 함수에서 사용된 &lt;code>this&lt;/code>는 block을 타고 올라갔을 때, 맨 처음 만나는 일반 함수의 &lt;code>this&lt;/code>를 가리킨다.&lt;/li>
&lt;li>&lt;code>new&lt;/code> 키워드를 사용할 경우 생성자 함수가 객체 그 자체가 된다. 생성자 함수는 일반 함수여야한다. 생성자 함수 호출 시 &lt;code>this&lt;/code>는 무조건 자기 자신이다.&lt;/li>
&lt;/ol>
&lt;h3 id="첫-번째-규칙---일반-함수의-this">첫 번째 규칙 - 일반 함수의 &lt;code>this&lt;/code>&lt;/h3>
&lt;blockquote>
&lt;p>일반 함수(function 키워드 사용)에서 사용된 &lt;code>this&lt;/code>는 해당 함수를 호출하는 객체를 가리킨다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNumber&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">number&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span>) &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>) &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>해당 방식은 다른 언어와 유사하게 작동하는 것을 알 수 있다.&lt;/p>
&lt;p>규칙에 맞게 따져보자.&lt;/p>
&lt;ul>
&lt;li>&lt;code>setNumber&lt;/code> 함수가 일반 함수로 선언되어 있음.&lt;/li>
&lt;li>&lt;code>setNumber&lt;/code> 함수를 &lt;code>test&lt;/code> 객체가 호출함.
&lt;ul>
&lt;li>ex. &lt;code>test.setNumber(1)&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-&amp;gt; &lt;code>setNumber&lt;/code> 에서 &lt;code>this&lt;/code> = &lt;code>test&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>그렇다면 &lt;code>setNumber&lt;/code> 함수를 다른 객체에서 사용하면 어떻게 될까?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNumber&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">number&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">other&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">other&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">other&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span>) &lt;span style="color:#75715e">// undefined
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">other&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span>) &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>) &lt;span style="color:#75715e">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">other&lt;/span>) &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>test&lt;/code> 의 &lt;code>setNumber&lt;/code> 를 &lt;code>other&lt;/code> 의 &lt;code>setNumber&lt;/code> 로 옮김.&lt;/li>
&lt;li>&lt;code>other.setNubmer(1)&lt;/code> 을 실행.&lt;/li>
&lt;li>-&amp;gt; &lt;code>this&lt;/code> = &lt;code>other&lt;/code> 임을 알 수 있음.&lt;/li>
&lt;/ul>
&lt;p>즉, 규칙에 따라, &lt;code>this&lt;/code>는 일반함수를 호출하는 객체임을 알 수 있다.&lt;/p>
&lt;h3 id="두-번째-규칙---화살표-함수의-this">두 번째 규칙 - 화살표 함수의 &lt;code>this&lt;/code>&lt;/h3>
&lt;blockquote>
&lt;p>화살표 함수에서 사용된 &lt;code>this&lt;/code> 는 block 계층을 타고 올라갔을 때, 맨 처음 만나는 일반 함수의 &lt;code>this&lt;/code> 를 가리킨다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNumber&lt;/span>&lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">number&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span>) &lt;span style="color:#75715e">// undefined
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>) &lt;span style="color:#75715e">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> window) &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>해당 코드를 보면, &lt;code>setNumber&lt;/code> 내부의 &lt;code>this&lt;/code> 가 window 객체임을 알 수 있다. 왜 이런 현상이 발생한 것 일까?&lt;/p>
&lt;p>규칙에 맞게 한번 따져보자,&lt;/p>
&lt;ul>
&lt;li>&lt;code>setNumber&lt;/code> 는 화살표 함수임.&lt;/li>
&lt;li>&lt;code>setNumber&lt;/code> 의 상위 블록은 전역 객체인 &lt;code>window&lt;/code> 임.&lt;/li>
&lt;li>맨 처음 만나는 일반 함수가 없었으므로, &lt;code>window&lt;/code> = &lt;code>this&lt;/code> 임을 알 수 있음.&lt;/li>
&lt;/ul>
&lt;p>이번엔 일반함수가 있는 경우를 알아보자&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNumber&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">number&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">number&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(&lt;span style="color:#a6e22e">number&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span>) &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>) &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> window) &lt;span style="color:#75715e">// false
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이번 코드의 결과는 위의 결과와 완전히 정반대라는 것을 알 수 있다.&lt;/p>
&lt;p>다시한번 규칙에 맞게 따져보자.&lt;/p>
&lt;ul>
&lt;li>&lt;code>setNumber&lt;/code> 는 일반 함수임.&lt;/li>
&lt;li>&lt;code>setNumber&lt;/code> 내부에 &lt;code>run&lt;/code> 이라는 화살표 함수가 존재함.&lt;/li>
&lt;li>&lt;code>setNumber&lt;/code> 는 &lt;code>run&lt;/code> 을 실행한 후 결과를 반환함.&lt;/li>
&lt;li>&lt;code>run&lt;/code> 의 상위 계층 블록은 &lt;code>setNumber&lt;/code>이고, &lt;code>setNumber&lt;/code> 의 상위 계층 블록은 &lt;code>window&lt;/code> 임.&lt;/li>
&lt;li>&lt;code>run&lt;/code> 에게는 &lt;code>setNumber&lt;/code> 가 상위 계층 블록 중 처음 만나는 일반 함수이므로 &lt;code>setNumber&lt;/code> 의 &lt;code>this&lt;/code> 가 바로 &lt;code>run&lt;/code> 의 &lt;code>this&lt;/code> 임.&lt;/li>
&lt;li>&lt;code>setNumber&lt;/code> 를 호출한 객체는 &lt;code>test&lt;/code> 객체임&lt;/li>
&lt;li>그러므로 &lt;code>this&lt;/code> = &lt;code>test&lt;/code> 임을 알 수 있음.&lt;/li>
&lt;/ul>
&lt;h3 id="세-번째-규칙---new-키워드">세 번째 규칙 - new 키워드&lt;/h3>
&lt;blockquote>
&lt;p>&lt;code>new&lt;/code> 키워드를 사용할 경우 생성자 함수가 객체 그 자체가 된다. 생성자 함수는 일반 함수여야한다. 생성자 함수 호출 시 &lt;code>this&lt;/code>는 무조건 자기 자신이다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#a6e22e">number&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span>) &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>) &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>해당 코드는 &lt;code>setNumber&lt;/code>가 일반함수이므로 당연히 &lt;code>this&lt;/code> 가 &lt;code>test&lt;/code> 임을 알 수 있다.&lt;/p>
&lt;p>그런데 만약 아래와 같은 코드가 있다면 어떨까?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">setNumber&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">number&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span>) &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>) &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>해당 코드는 &lt;code>setNumber&lt;/code>가 화살표 함수이므로, 앞서 말했던 것 처럼 &lt;code>this&lt;/code>가 &lt;code>window&lt;/code>가 될 것 같지 않은가?&lt;/p>
&lt;p>그렇지 않다. 위 코드는 아래와 같은 코드이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">number&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Test&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">setNumber&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">number&lt;/span>) &lt;span style="color:#75715e">// 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>) &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>js에서는 함수에 &lt;code>new&lt;/code>를 붙여버리면, 그 함수가 생성자 함수가 되어버린다. 그리고 &lt;code>new&lt;/code>는 일반 함수에만 붙일 수 있다.&lt;/p>
&lt;p>그렇다면 &lt;code>setNumber&lt;/code>의 맨 처음 만나는 상위 블록의 일반 함수가 생성자이고, 생성자의 호출시 &lt;code>this&lt;/code>는 자기자신이므로 &lt;code>setNumber&lt;/code>의 &lt;code>this&lt;/code>는 &lt;code>test&lt;/code>가 된다.&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;p>해당 내용은 &lt;a class="link" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener"
>mdn web docs - this&lt;/a>을 참고해서 작성한 글이다. 더 자세한 정보를 얻고 싶다면 문서에서 확인해보자.&lt;/p>
&lt;ul>
&lt;li>&lt;code>this&lt;/code> 바인딩 정리
&lt;ol>
&lt;li>일반 함수(function 키워드 사용)에서 사용된 &lt;code>this&lt;/code>는 해당 함수를 호출하는 객체를 가리킨다.&lt;/li>
&lt;li>화살표 함수에서 사용된 &lt;code>this&lt;/code>는 block을 타고 올라갔을 때, 맨 처음 만나는 일반 함수의 &lt;code>this&lt;/code>를 가리킨다.&lt;/li>
&lt;li>&lt;code>new&lt;/code> 키워드를 사용할 경우 생성자 함수가 객체 그 자체가 된다. 생성자 함수는 일반 함수여야한다. 생성자 함수 호출 시 &lt;code>this&lt;/code>는 무조건 자기 자신이다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>최상위 &lt;code>this&lt;/code>는 &lt;code>window&lt;/code> 이다.(node.js에서는 global)&lt;/li>
&lt;/ul>
&lt;div id="fhdufhdu-card">
&lt;/div>
&lt;script>
const resize = () => {
var iamges = []
var interval = setInterval(()=>{
images = document.querySelectorAll('.gallery')
if (images.length > 0){
images.forEach((image)=>{
const getEm = (width) => {
if (width > 1535) return 4
else if(width &lt; 0) return 0
return (4/767) * width - (3072/767)
}
const em = getEm(window.innerWidth)
image.style.padding = `0 ${em}em 0 ${em}em`
})
clearInterval(interval)
}
}, 100)
}
window.addEventListener("resize", resize)
resize()
&lt;/script></description></item><item><title>[JS] 이벤트 루프와 비동기 함수</title><link>https://fhdufhdu.github.io/post/5/</link><pubDate>Wed, 03 Jan 2024 23:34:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/5/</guid><description>&lt;p>오늘은 JS의 비동기에 관해 설명해 보고자 한다. JS에 대해 잘 모르고 비동기에 대한 개념이 희박하던 때, 단순히 콜백함수가 비동기 함수인 줄 알았다. 하지만 단순히 콜백함수를 만든다고 해서 비동기적으로 작동하는 것은 아니다. 특정 조건의 함수만 비동기 함수가 될 수 있다.&lt;/p>
&lt;p>동기와 비동기 작업에 대해 알아보고 싶다면 해당&lt;a class="link" href="https://fhdufhdu.github.io/page/4" >게시글&lt;/a>을 참고하자.&lt;/p>
&lt;p>조금 더 자세히 알아보자.&lt;/p>
&lt;h2 id="콜백-함수는-동기이다">콜백 함수는 동기이다.&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">num&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">callback&lt;/span>(&lt;span style="color:#a6e22e">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">count&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, (&lt;span style="color:#a6e22e">num&lt;/span>) =&amp;gt;{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#a6e22e">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;============================&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">count&lt;/span>(&lt;span style="color:#ae81ff">1000&lt;/span>, (&lt;span style="color:#a6e22e">num&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">1000&lt;/span>, &lt;span style="color:#a6e22e">num&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>count 함수는 파라미터 num에 10번 반복문을 돌면서 1을 더하는 함수이다. 그리고 for가 끝나면 콜백을 실행한다.&lt;/p>
&lt;p>해당 코드를 실행하면 아래와 같은 결과가 나온다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>============================
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1001
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1002
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1003
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1004
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1005
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1006
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1007
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1008
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1009
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1000 1010
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>완벽하게 동기로 실행되는 것을 볼 수 있다. 그러므로 콜백함수를 만든다고 해서 비동기로 작동하지 않는다.&lt;/p>
&lt;h2 id="javascript-런타임">javascript 런타임&lt;/h2>
&lt;p>js에서 비동기를 이해하기 위해서는 &lt;code>javacript 런타임&lt;/code> 에 대해 이해할 필요가 있다.&lt;/p>
&lt;p>런타임은 어떠한 코드가 실제로 구동할 수 있는 환경을 의미힌다. 그러므로 당연하게도 &lt;code>javascript 런타임&lt;/code>은 js 코드를 실제로 구동할 수 있는 환경이다.&lt;/p>
&lt;p>&lt;code>javascript 런타임&lt;/code>도 종류가 있는데, 크게 분리하면 &lt;code>웹 브라우저&lt;/code> 와 &lt;code>node.js&lt;/code>가 있다. 웹 브라우저는 흔히 사용하는 크롬, 사파리, 파이어폭스 등이 있다.&lt;/p>
&lt;p>앞서 런타임은 구동 환경을 의미한다고 했다. &lt;code>javascript 런타임&lt;/code>에는 어떤 종류의 환경이 존재할까?&lt;/p>
&lt;ul>
&lt;li>&lt;code>javacript 엔진&lt;/code>
&lt;ul>
&lt;li>&lt;code>이벤트 루프&lt;/code> 포함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Web APIs&lt;/code>(node.js에서는 &lt;code>libuv&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>이 두가지가 존재한다.&lt;/p>
&lt;h3 id="javascript-엔진">javascript 엔진&lt;/h3>
&lt;p>그렇다면 &lt;code>javascript 엔진&lt;/code>이란 무엇일까? js 코드를 실제로 실행하는 영역이다. 개발자가 작성한 모든 js 코드는 &lt;code>javascript 엔진&lt;/code>에서 파싱되고 실행된다. 이 &lt;code>javascript 엔진&lt;/code>은 &lt;strong>싱글 스레드&lt;/strong>에서 작동한다.&lt;/p>
&lt;p>여기에는 흔히 알려져 있는 &lt;code>이벤트 루프&lt;/code>도 포함되어 있다. &lt;code>이벤트 루프&lt;/code>에 대해서는 뒤에서 자세하게 설명하도록 하겠다. 우선 이 &lt;code>이벤트 루프&lt;/code>가 &lt;code>javascript 엔진&lt;/code>에서 작동한다는 사실만 기억하자.&lt;/p>
&lt;h4 id="javascript-엔진의-구성-요소">javascript 엔진의 구성 요소&lt;/h4>
&lt;ul>
&lt;li>콜 스택 (call stack)
&lt;ul>
&lt;li>
&lt;p>실행되어야할 함수들을 저장하는 곳&lt;/p>
&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">num&lt;/span>) =&amp;gt; { &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">num&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://fhdufhdu.github.io/post/5/image.png"
width="1280"
height="678"
loading="lazy"
alt="JS 콜스택"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="453px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;code>test(1)&lt;/code>이 이 콜스택에 삽입 후 실행&lt;/li>
&lt;li>&lt;code>test(1)&lt;/code>에 있는 &lt;code>console.log(1)&lt;/code>을 콜스택에 삽입 후 실행&lt;/li>
&lt;li>1이 출력 후 &lt;code>console.log(1)&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>&lt;code>test(1)&lt;/code> 콜스택에서 제거&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>힙 (heap)
&lt;ul>
&lt;li>데이터가 동적으로 저장되는 공간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이벤트 루프(event loop)
&lt;ul>
&lt;li>비동기 작업이 끝난 후 결과값을 처리할 &lt;strong>콜백 함수를 저장해두는 곳&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="web-apis">Web APIs&lt;/h3>
&lt;p>&lt;code>웹 브라우저&lt;/code>에서 비동기적인 이벤트를 처리하기 위해 제공하는 API들이다. &lt;code>웹 브라우저&lt;/code>에서 제공하는 것이기 때문에, 해당 api는 &lt;code>javascript 엔진&lt;/code>에서 실행되지 않는다. 이 api들은 &lt;code>javascript 엔진&lt;/code>과 실제로 다른 프로세스에서 실행되며, js에서 호출할 수 있도록 &lt;code>javascript 엔진&lt;/code>에서는 인터페이스만 제공한다.&lt;/p>
&lt;h4 id="여기서-잠깐-인터페이스만-제공한다는-것의-의미란">여기서 잠깐! 인터페이스만 제공한다는 것의 의미란?&lt;/h4>
&lt;p>API는 Application Programming Interface의 약자이다. 이는 &lt;strong>두 개의 서로 다른 프로세스(혹은 프로그램)간에 통신을 위한 일종의 약속&lt;/strong>이다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>A&lt;/code>와 &lt;code>B&lt;/code>라는 두 개의 프로세스가 있고, &lt;code>B&lt;/code>에는 &lt;code>getData&lt;/code>라는 기능이 있다. &lt;code>A&lt;/code>에서 &lt;code>B&lt;/code>의 &lt;code>getData&lt;/code>라는 기능을 사용하기 위해서는 &lt;code>getData&lt;/code>의 실행에 필요한 데이터를 전달해 주어야 한다.
이때 &lt;strong>&amp;quot;&lt;code>B&lt;/code>는 특정 형태의 프로토콜과 특정 형태의 구조로 데이터를 전달해주면, &lt;code>getData&lt;/code>라는 기능을 실행하고, 결과를 특정한 형태로 응답해주겠다&amp;quot;&lt;/strong> 라고 약속하는 것이 바로 API라고 할 수 있다.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>Web APIs&lt;/code>도 똑같다. 실제 &lt;code>Web APIs&lt;/code>는 js 코드로 실행하면, &lt;code>javascript 엔진&lt;/code>이 해당 요청을 다른 프로세스(=웹 브라우저)에게 요청하고, 응답을 받으면 그것을 js에서 사용할 수 있도록 결과값을 반환해주는 역할을 한다.&lt;/p>
&lt;p>즉, &lt;code>javascript 엔진&lt;/code>과 &lt;code>웹 브라우저&lt;/code> 간의 통신 약속이 바로 &lt;code>Web APIs&lt;/code>이다.&lt;/p>
&lt;p>해당 게시글을 처음 시작할 때, 특정 조건의 함수만 비동기가 될 수 있다고 했다. 그 특정 조건의 함수란 바로, &lt;code>Web APIs&lt;/code>에 등록된 함수이다.&lt;/p>
&lt;p>&lt;a class="link" href="https://developer.mozilla.org/ko/docs/Web/API" target="_blank" rel="noopener"
>Web APIs 함수 목록-mdn web docs&lt;/a>&lt;/p>
&lt;h2 id="이벤트-루프">이벤트 루프&lt;/h2>
&lt;p>이벤트 루프를 이해하기 위해서는 비동기에 대한 이해가 필요하다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;!-- raw HTML omitted -->비동기란?&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->
파일 저장, 네트워크 요청 등 처리에 시간이 걸리는 I/O 작업이 진행 중에 다른 코드를 실행하는 것을 의미한다.&lt;!-- raw HTML omitted -->
시간이 걸리는 작업 중에는 프로그램은 놀고 있는 것이기 때문에, 이 시간을 최대한 활용하기 위해 나온 개념이다.&lt;/p>
&lt;/blockquote>
&lt;p>js는 싱글 스레드이기 때문에, 비동기 코드를 실행할 수 없다. 그래서 앞서 설명한 &lt;code>Web APIs&lt;/code>를 통해 브라우저에게 비동기 작업을 요청한다. 그렇다면, 비동기 작업이 종료되었을때, 응답을 받을 것이다. 그 응답은 어떻게 처리해야 할까?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">setTimeout&lt;/span>(()=&amp;gt;{&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)}, &lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">결과
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위와 같은 코드를 보자. 해당 코드는 실행하면 2가 출력되고 1초 후 1이 출력될 것이다. 조금 이상하지 않은가? 코드는 위에서 아래로 진행하면서 실행될 텐데, 1, 2가 출력되는 것이 아니라 2, 1로 반대로 출력된다. 마치 이것은 두 번째 줄이 먼저 실행되고, 첫 번째 줄이 실행된 것 처럼 보인다.&lt;/p>
&lt;p>이것이 앞서 설명한 응답 처리에 대한 질문의 답이라고 할 수 있다. 코드 실행을 순서대로 알아보자&lt;/p>
&lt;ul>
&lt;li>&lt;code>setTimeout&lt;/code> 콜스택에 삽입 후 실행&lt;/li>
&lt;li>1초 타이머를 &lt;code>Web API&lt;/code>를 통해 &lt;code>웹 브라우저&lt;/code>에게 요청, 이때 &lt;code>()=&amp;gt;{console.log(1)}&lt;/code>을 같이 &lt;code>웹 브라우저에게 전달&lt;/code>&lt;/li>
&lt;li>&lt;code>setTimeout&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>&lt;code>console.log(2)&lt;/code> 콜스택에 삽입 후 실행&lt;/li>
&lt;li>2 출력&lt;/li>
&lt;li>&lt;code>console.log(2)&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>1초가 지난 후 &lt;code>웹 브라우저&lt;/code>는 &lt;code>()=&amp;gt;{console.log(1)}&lt;/code>을 &lt;code>이벤트 루프&lt;/code> 큐에 삽입&lt;/li>
&lt;li>&lt;code>이벤트 루프&lt;/code>는 큐에 &lt;code>()=&amp;gt;{console.log(1)}&lt;/code>가 생겼으므로, 해당 함수를 콜스택에 삽입&lt;/li>
&lt;li>&lt;code>()=&amp;gt;{console.log(1)}&lt;/code> 실행&lt;/li>
&lt;li>&lt;code>console.log(1)&lt;/code> 콜스택에 삽입 후 실행&lt;/li>
&lt;li>1 출력&lt;/li>
&lt;li>&lt;code>console.log(1)&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>&lt;code>()=&amp;gt;{console.log(1)}&lt;/code> 콜스택에서 제거&lt;/li>
&lt;li>종료&lt;/li>
&lt;/ul>
&lt;p>이렇듯, 코드는 순차적으로 실행된 것이 맞고, 응답 처리의 방법은 비동기 작업이 종료된 이후 처리할 코드를 미리 넘겨주는 것이다. 이것이 바로 &lt;code>콜백 함수&lt;/code>이다. 위 예제에서 콜백 함수는 &lt;code>()=&amp;gt;{console.log(1)}&lt;/code>이다.&lt;/p>
&lt;p>그리고 이벤트 루프의 역할은 &lt;strong>비동기 처리가 완료된 이후 실행되어야 할 콜백 함수들의 저장소&lt;/strong>이다. 이 이벤트 루프는 콜백 함수를 저장하고, 일정 주기(틱)마다 콜백 함수 큐를 확인해서 콜백 함수가 존재하면 해당 함수를 콜 스택에 삽입한다.&lt;/p>
&lt;p>아래 GIF를 보면 &lt;code>콜 스택&lt;/code>, &lt;code>웹 브라우저&lt;/code>, &lt;code>이벤트 루프&lt;/code>간의 상호작용을 한눈에 볼 수 있다.&lt;/p>
&lt;p>&lt;img src="https://fhdufhdu.github.io/post/5/event-loop.gif"
width="720"
height="405"
loading="lazy"
alt="JS 비동기 작업 GIF"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;h2 id="정리">정리&lt;/h2>
&lt;ul>
&lt;li>콜백을 사용한다고 모두 비동기가 되는 것이 아니다.&lt;/li>
&lt;li>&lt;code>javascript 런타임&lt;/code>은 js를 실행하는 구동 환경이다.
&lt;ul>
&lt;li>&lt;code>javascript 엔진&lt;/code>과 &lt;code>Web APIs&lt;/code>로 구성된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>javascript 엔진&lt;/code>은 js를 파싱하고 실행한다.
&lt;ul>
&lt;li>싱글 스레드로 작동한다.&lt;/li>
&lt;li>여기서는 비동기가 작동할 수 없다.&lt;/li>
&lt;li>&lt;code>콜 스택&lt;/code>, &lt;code>힙&lt;/code>, &lt;code>이벤트 루프&lt;/code>로 구성된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Web APIs&lt;/code>는 &lt;code>웹 브라우저&lt;/code>에서 비동기 이벤트를 처리하기 위해 제공되는 api이다.
&lt;ul>
&lt;li>&lt;code>javascript 엔진&lt;/code>은 비동기 요청을 &lt;code>Web APIs&lt;/code>를 통해 &lt;code>웹 브라우저&lt;/code>에게 전달한다.&lt;/li>
&lt;li>&lt;code>웹 브라우저&lt;/code>는 비동기 작업이 끝나면 콜백 함수를 &lt;code>이벤트 루프&lt;/code> 콜백 함수 큐에 삽입힌다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>콜백 함수&lt;/code>란 비동기 요청이 끝난 후 응답을 처리하는 함수이다.&lt;/li>
&lt;li>&lt;code>이벤트 루프&lt;/code>란 콜백 함수 저장소이다.
&lt;ul>
&lt;li>&lt;code>일정 주기(틱)&lt;/code>마다 콜백 함수 큐를 검사하고, 콜백 함수가 존재하면 콜 스택에 해당 함수를 삽입한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div id="fhdufhdu-card">
&lt;/div>
&lt;script>
const resize = () => {
var iamges = []
var interval = setInterval(()=>{
images = document.querySelectorAll('.gallery')
if (images.length > 0){
images.forEach((image)=>{
const getEm = (width) => {
if (width > 1535) return 4
else if(width &lt; 0) return 0
return (4/767) * width - (3072/767)
}
const em = getEm(window.innerWidth)
image.style.padding = `0 ${em}em 0 ${em}em`
})
clearInterval(interval)
}
}, 100)
}
window.addEventListener("resize", resize)
resize()
&lt;/script></description></item><item><title>[CS] 동기/비동기에 대해서 알아보자(sync/async)</title><link>https://fhdufhdu.github.io/post/4/</link><pubDate>Tue, 02 Jan 2024 22:15:00 +0900</pubDate><guid>https://fhdufhdu.github.io/post/4/</guid><description>&lt;p>오늘은 동기와 비동기에 대해서 설명하고자 한다.&lt;/p>
&lt;p>해당 개념은 설명만 들으면 쉽게 이해가 될 수도 있지만, 헷갈릴 여지도 많은 개념이라고 생각한다.&lt;/p>
&lt;p>특히 스레드 개념과 엮이기 시작하면 많이 헷갈리기 시작하는 개념이다.&lt;/p>
&lt;h2 id="동기sync">동기(Sync)&lt;/h2>
&lt;p>동기가 제일 간단하다. 흔히 우리가 쓰는 코드를 상상하면 된다.&lt;/p>
&lt;p>아래 JS 예제가 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> 결과는 위에서부터 순차적으로 실행되어 아래와 같은 결과를 보일 것이다.&lt;/p>
&lt;p>&lt;img src="https://fhdufhdu.github.io/post/4/image.png"
width="210"
height="216"
loading="lazy"
alt="코드 결과"
class="gallery-image"
data-flex-grow="97"
data-flex-basis="233px"
>&lt;/p>
&lt;h2 id="비동기async">비동기(Async)&lt;/h2>
&lt;p>자 이제 비동기에 대해 이해해 보자. 단순하게 비동기는 동기의 반대말이다. 동기가 순차적으로 실행되는 것을 의미하니까 비동기는 순차적으로 실행되지 않는다고 생각하면 된다. 순차적으로 실행되지 않는다면, 코드의 실행순서를 파악하기 힘들 것이다. 이렇게 생각했을 때 비동기가 정말 필요한지에 대해 의문점이 생긴다.&lt;/p>
&lt;h3 id="비동기의-필요성">비동기의 필요성&lt;/h3>
&lt;p>비동기가 등장한 이유는 낭비되는 시간이 아까워서이다. 아래와 같은 코드를 보자&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 해당 코드는 psuedo 코드이다.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">reqBody&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;choding&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;is good&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">response&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">requests&lt;/span>.&lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://localhost:3000&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">reqBody&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 이후 필요한 로직 실행!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>단순하게 http 요청을 보내는 코드이다. 이 코드가 동기적으로 작동한다면 대락 100초 이후에 console.log(response.body)가 실행되고 이후 로직이 작동할 것이다. 근데 http 요청을 보내고, 받는 100초 동안 프로세스는 무엇을 하고 있을까?&lt;/p>
&lt;p>정답은 &lt;strong>&amp;ldquo;아무것도 안하고 있다.&amp;rdquo;&lt;/strong> 이다. 정말 아무것도 안 하고 http 응답을 받는 순간까지 기다리는 것만 진행할 것이다. 만약 이 100초라는 시간에 다른 작업을 하면 어떨까? 웬만하면 많은 작업들을 처리할 수 있을 것이다.&lt;/p>
&lt;p>이 남는 시간을 활용하기 위해 비동기라는 개념이 등장했다.&lt;/p>
&lt;p>&lt;img src="https://fhdufhdu.github.io/post/4/image-1.png"
width="1440"
height="554"
loading="lazy"
alt="비동기 작동 과정"
class="gallery-image"
data-flex-grow="259"
data-flex-basis="623px"
>&lt;/p>
&lt;p>위 그림처럼, 2번이 완료되지 않았음에도, 2번의 응답이 오기까지의 시간동안 다른 작업을 하는 것이 바로 비동기라고 할 수 있다.&lt;/p>
&lt;h3 id="콜백">콜백&lt;/h3>
&lt;p>앞서 비동기의 필요성을 말했다. 그렇다면 100초 동안 비는 시간에 다른 작업을 하고 나서, 응답을 받는 순간에는 어떻게 될까? 해당 값으로 처리하는 로직이 필요할 것이다. 그것이 바로 콜백(callback)이다.&lt;/p>
&lt;p>콜백의 주요 논지는 &lt;strong>&amp;ldquo;해야할 일을 뒤로 미루는 것&amp;rdquo;&lt;/strong> 이다.&lt;/p>
&lt;p>사실, 이름만 봐도 알 수 있다. callback은 회신하다/답신하다는 뜻이다.&lt;/p>
&lt;p>그러니까 &amp;ldquo;할일 다 하고(=해야 할 일 미루고), 네가 요청한 일 처리할 수 있을 때 처리하겠다&amp;quot;라는 것이다.&lt;/p>
&lt;p>아래 코드를 다시 보자.&lt;/p>
&lt;p>2번 과정이 100초가 걸리니까, 2번의 응답이 오는 100초 동안 다른 일을 JS가 한다고 하자. 이후 100초가 지난 후, 2번의 응답을 가지고 무언가 작업을 해야 할 것이다. 그런데, 어떻게 실행할 것인가? &lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 해당 코드는 psuedo 코드이다.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">reqBody&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;choding&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;is good&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">requests&lt;/span>.&lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://localhost:3000&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">reqBody&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">body&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 이후 필요한 로직 실행!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//100초 후...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//어라, 어떻게 응답을 처리하지?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//응답은 왔는데.... 처리할 코드를 어떻게 작성하지...?
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이때 콜백을 작성하면 응답을 처리할 수 있는 코드를 작성할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 해당 코드는 psuedo 코드이다.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">reqBody&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;choding&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;is good&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//2. 해당 http 요청이 100초가 오래걸린다는 것을 가정하자
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">requests&lt;/span>.&lt;span style="color:#a6e22e">post&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://localhost:3000&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">reqBody&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 4. 100초 후 이 함수 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">response&lt;/span>.&lt;span style="color:#a6e22e">body&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 처럼 콜백 함수를 작성할 수 있을 것이다. 저 4번 콜백 함수는 http 응답이 오면 실행된다.&lt;/p>
&lt;p>4번의 콜백 함수는 앞서 말한 &lt;strong>&amp;ldquo;해야 할 일을 뒤로 미루는 것&amp;quot;과&lt;/strong> 같다.&lt;/p>
&lt;h2 id="마무리">마무리&lt;/h2>
&lt;p>간단하게 비동기와 콜백에 대해 알아보았다.&lt;/p>
&lt;p>이렇게 보면 비동기 자체는 크게 어렵지 않은 것 같다. 하지만 필자도 이 개념을 오해 없이 이해하기에 많은 시간이 들었다.&lt;/p>
&lt;p>여러분들도 오해없이 비동기를 이해할 수 있게 되었으면 좋겠다.&lt;/p>
&lt;div id="fhdufhdu-card">
&lt;/div>
&lt;script>
const resize = () => {
var iamges = []
var interval = setInterval(()=>{
images = document.querySelectorAll('.gallery')
if (images.length > 0){
images.forEach((image)=>{
const getEm = (width) => {
if (width > 1535) return 4
else if(width &lt; 0) return 0
return (4/767) * width - (3072/767)
}
const em = getEm(window.innerWidth)
image.style.padding = `0 ${em}em 0 ${em}em`
})
clearInterval(interval)
}
}, 100)
}
window.addEventListener("resize", resize)
resize()
&lt;/script></description></item></channel></rss>