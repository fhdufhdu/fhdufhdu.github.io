---
layout: post
title:  "[JS] 이벤트 루프와 비동기 함수"
excerpt: "싱글 스레드에서 어떻게 비동기를 사용할 수 있는지 이벤트 루프와 함께 알아보자"
author: fhdufhdu
categories: [ javascript ]
date: '2024-01-03 23:34'
---
오늘은 JS의 비동기에 대해 설명해보고자 한다.

JS에 대해 잘 모르고 비동기에 대한 개념이 희박하던 때, 단순히 콜백함수가 비동기 함수인 줄 알았다.

하지만 단순히 콜백함수를 만든다고 해서 비동기적으로 작동하는 것은 아니다. 모든 JS의 비동기는 이벤트 루프에 등록되어야 한다.

조금 더 자세히 알아보자.

동기와 비동기 작업에 대해 알아보고 싶다면 아래 게시글을 참고하자.

[2024.01.02 - \[CS\] - \[CS\] 동기/비동기에 대해서 알아보자(sync/async)]({{site.baseurl}}/cs-동기비동기에대해서알아보자/)

## 콜백 함수는 동기이다.

``` js
const count = (num, callback) => {
    for (let i = 0; i < 10; i++){
        console.log(num)
        num += 1
    }
    callback(num)
}


count(1, (num) =>{
    console.log(1, num)
})
console.log("============================")
count(1000, (num) => {
    console.log(1000, num)
})
```

count 함수는 파라미터 num에 10번 반복문을 돌면서 1을 더하는 함수이다. 그리고 for가 끝나면 콜백을 실행한다.

해당 코드를 실행하면 아래와 같은 결과가 나온다.

``` bash
1
2
3
4
5
6
7
8
9
10
1 11
============================
1000
1001
1002
1003
1004
1005
1006
1007
1008
1009
1000 1010
```

완벽하게 동기로 실행되는 것을 볼 수 있다. 그러므로 콜백함수를 만든다고 해서 비동기로 작동하지 않는다.

## 그럼 비동기는 어떤 함수가 사용되는가?

### 우선 이벤트 루프에 대해 이해해 보자

JS는 싱글 스레드로 작동한다. 이 싱글 스레드에서 비동기를 가능하게 해주는 것이 바로 WEB API와 이벤트 루프이다.

``` js
setTimeout(()=>{console.log(1)}, 4000)

setTimeout(()=>{console.log(2)}, 2000)

setTimeout(()=>{console.log(3)}, 3000)

setTimeout(()=>{console.log(4)}, 1000)

console.log(5)
```

해당 코드의 결과는 아래와 같다

![image](https://github.com/fhdufhdu/fhdufhdu.github.io/assets/32770312/c8fcbf83-d788-4ab8-870c-b1eb88fc6002)

완벽하게 비동기로 작동하는 것이 보인다. 그렇다면 실행 순서를 알아보자

1.  `setTimeout(()=>{console.log(1)}, 4000)` 실행, WEB API에서 4초 타이머가 작동함
2.  `setTimeout(()=>{console.log(2)}, 2000)` 실행, WEB API에서 2초 타이머가 작동함
3.  `setTimeout(()=>{console.log(3)}, 3000)` 실행, WEB API에서 3초 타이머가 작동함
4.  `setTimeout(()=>{console.log(4)}, 1000)` 실행, WEB API에서 1초 타이머가 작동함
5.  `console.log(5)` 실행 -> 5가 출력됨
6.  모든 코드가 마무리되었으므로, WEB API를 확인해서 비동기 작업이 끝난 것이 있는지 확인.
7.  1초 후 WEB API에서 비동기 작업이 끝난 것을 확인. `()=>{console.log(4)}` 함수를 이벤트 루프의 큐에 삽입.
8.  이벤트 루프에서 콜백 함수를 가져와서 콜스택에 추가 -> 콜스택 실행 -> 4가 출력됨
9.  2초 후 WEB API에서 비동기 작업이 끝난 것을 확인. `()=>{console.log(2)}` 함수를 이벤트 루프의 큐에 삽입
10.  8번과 작업 동일
11.  3초 후 WEB API에서 비동기 작업이 끝난 것을 확인. `()=>{console.log(3)}` 함수를 이벤트 루프의 큐에 삽입
12.  8번과 작업 동일
13.  4초 후 WEB API에서 비동기 작업이 끝난 것을 확인. `()=>{console.log(1)}` 함수를 이벤트 루프의 큐에 삽입
14.  8번과 작업 동일

여기서 JS는 싱글 스레드인데 WEB API는 멀티 스레드처럼 작동하는 것을 볼 수 있다.

그것이 맞다. JS는 싱글 스레드에서 작동하지만, **WEB API는 다른 곳**(ex. 커널)**에게 작업을 위임**한다.

그래서 위의 타이머 작동은 JS에서 작동하는 것이 아닌, 다른 곳에서 작동하는 것이다.

**이후 타이머 작동이 끝나면, JS의 이벤트 루프에게 콜백을 전달하고, 이벤트 루프는 콜스택이 비워져 있을 때 이벤트 루프에 쌓인 콜백을 콜스택으로 전달해서 콜백 함수를 실행한다.**(7~14번 작업)

이벤트 루프는 비동기 작업을 처리하는 곳이 아니다. **이벤트 루프는 비동기 작업이 끝난 후 실행되어야 할 콜백들이 저장된 곳이다. 실질적인 비동기 작업은 WEB API에서 처리된다.** 또한 이벤트 루프는 WEB API와 다르게 JS에서 작동하는 것이기 때문에 비동기 작업을 할 수 없다.

아래 GIF를 보면 더욱 이해가 잘 될 것이다.

![image]({{baseurl}}/assets/images/js-event-loop.gif)

### 비동기가 되기 위한 조건

자, 위에서 이벤트 루프에 대해 알아보았다. 위에서 이벤트 루프는 비동기가 끝난 후 실행되어야 할 콜백 함수들이 저장된 곳이라고 말해주었다. 또한, 실질적인 비동기 작업은 WEB API에서 처리된다는 것도 알게 되었다.

그렇다면 WEB API에 작업을 위임할 수 있는 것에는 무엇이 있을까?

-   I/O 작업 (File, Network)
-   Timer

아까 말했다시피 WEB API는 다른 곳에서 작업을 수행한다. 그렇기에 해당 작업을 수행하는 동안 JS는 놀고 있게 되고, 이는 싱글스레드에서 비동기가 가능하게 되는 이유다.

## 정리

-   콜백을 사용한다고 모두 비동기가 되는 것이 아니다.
-   JS는 싱글 스레드이다. 일반적으로 싱글 스레드에서는 비동기가 불가능하다.
-   이를 가능하게 해주는 것이 WEB API와 이벤트 루프이다.
-   WEB API는 JS가 아닌 다른 곳에서 실행된다.
-   이벤트 루프는 JS의 일부이다.(=JS에서 실행된다)
-   이벤트 루프는 비동기 작업(=WEB API 작업)이 끝난 후 실행될 콜백 함수가 저장된 곳이다.
-   WEB API에서 실행가능한 작업의 종류에는 I/O작업과 Timer가 있다.